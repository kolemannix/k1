// fn map(a: Array[int], f: \int -> int): Array[int] {
//   for i in a yield { f(i) }
// }

fn simpleAddOne(x: int): int { x + 1 }

// fn __clos_addOne(x: int, env: { closedOver: int }*): int { x + { (*env).closedOver } }

fn main(): int {
  val closedOver: int = 3;

  val addOne = \x: int -> x + 1;
  
  // round 2: reassign a closure
  // actually not, should fail typecheck
  val addOne2 = addOne;

  // round 3: Take the address of a function
  // val addOne3 = \i -> simpleAddOne(i);

  // printInt(addOne(1));
  printInt(addOne2(2));


  // round 4
  // map([1,2,3], \x -> x + 1);
  
  0
}
