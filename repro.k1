use core/BufferIterator

//fn find[T, I: Iterator[Item = T]](iter: I, pred: some \T -> bool): T? {
//  for i in iter do {
//    if pred(i) return(.Some(i))
//  };
//  return(.None)
//}

// a1 =:= I
// a2 =:= T
// <I's iterator impl .Item> =:= T
//fn position[T, I: Iterator[Item = T]](iter: I, needle: T): uword? {
//  for iter do {
//    if it == needle return(.Some(itIndex))
//  };
//  .None
//}

deftype Pair[PA, PB] = { a: PA*, b: PB? }
ability AsPair[AA, BB] {
  fn getA(self: Self): AA*
  fn getB(self: Self): BB?
}

impl[A, B] AsPair[AA = A, BB = B] for Pair[A, B] {
  fn getA(self: Pair[A, B]): A* { self.a }
  fn getB(self: Pair[A, B]): B? { self.b }
}
//impl AsPair[AA = int, BB = bool] for Pair[int, bool, unit] {
//  fn getA(self: Self): AA { self.a }
//  fn getB(self: Self): BB { self.b }
//}

fn unwrapB[
  X,
  Y,
  T: AsPair[AA=X, BB=Y] and AsPair[AA=Y, BB=X]
](t: T): Y? {
  t.getB();
  // -> AsPair/getB(t)
  // t: T: Self
  // <ret>: Opt[Y]
  // -> find all impls of base AsPair for T
  //   -> 1. AsPair[X, Y, Z]
  //   -> 2. AsPair[Y, X, Z]
  // Try impl 1:
  //   getB(): Opt[Y]
  // A :=
  t.getB()
}

//fn getBoth[A, B, T: AsPair[AA=A, BB=B]](t: T): { a: A, b: B } {
//  return({ a: *t.getA(), c: t.getB().! })
//}

fn getNothin[A, B, T: AsPair[AA=A, BB=B]](t: T): unit {
  ()
}

fn main(): i32 {
  // Phase 1
  let myPair: Pair[int, bool] = { a: mem/new(10), b: some(true) };
  getNothin(t = myPair);
  @debug unwrapB(myPair);

  // Phase 2
  //position[int, BufferIterator[int]](x, y);

  // Phase 3
  //find[
  //  int,
  //  BufferIterator[int]
  //](x, y);
  0
}
