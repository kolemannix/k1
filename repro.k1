use core/BufferIterator

fn find[
  T,
  Iter: Iterator[Item = T],
  I: Iterable[Item = T, I = Iter]
](iterable: I, pred: some \T -> bool): T? {
  for i in iterable do {
    if pred(i) return(.Some(i))
  };
  return(.None)
}

fn position[T: Equals, I: Iterator[Item = T]](iter: I, needle: T): uword? {
  for iter do {
    if it == needle return(.Some(itIndex))
  };
  .None
}

deftype Pair[PA, PB] = { a: PA*, b: PB? }
ability AsPair[AA, BB] {
  fn getA(self: Self): AA*
  fn getB(self: Self): BB?
}

impl[A, B] AsPair[AA = A, BB = B] for Pair[A, B] {
  fn getA(self: Pair[A, B]): A* { self.a }
  fn getB(self: Pair[A, B]): B? { self.b }
}

// blanket impl that insanely swaps the pair for you
impl[A, B] AsPair[AA = A, BB = B] for Pair[B, A] {
  fn getA(self: Pair[B, A]): A* { mem/new(self.b.!) }
  fn getB(self: Pair[B, A]): B? { some(self.a.*) }
}

fn unwrapB[
  X,
  Y,
  T: AsPair[AA=X, BB=Y] and AsPair[AA=Y, BB=X]
](t: T): Y {
  // Ability call resolution picks the implementation that results in the call working!
  let y: Y? = t.getB();
  y.!
}

//fn getBoth[A, B, T: AsPair[AA=A, BB=B]](t: T): { a: A, b: B } {
//  return({ a: *t.getA(), c: t.getB().! })
//}

fn getNothin[A, B, T: AsPair[AA=A, BB=B]](t: T): unit {
  ()
}

fn main(): i32 {
  // Phase 1
  let myPair: Pair[int, bool] = { a: mem/new(10), b: some(true) };
  getNothin(t = myPair);
  let b = unwrapB[int, bool, Pair[int, bool]](myPair);
  assert(b);
  let i = unwrapB[bool, int, Pair[int, bool]](myPair);
  assertEquals(i, 10);

  // Phase 3
  let firstOdd = find([1,2,3,4].toBuffer(): Buffer[int], \(x) x % 2 == 0);
  assertEquals(firstOdd, some(2));
  0
}
