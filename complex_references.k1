fn main(): int {
  let structRef: { x: int }* = { x: 42 }.&;

  let xValue: int = structRef.x*;
  let xRef: int* = structRef.x*;

  assert(xRef.* == xValue);
  assert(structRef.*.x == structRef.x);

  referenceSet(xRef, -10);
  
  assert(xRef.* == -10);

  // Future is
  // structRef.x <- 42;
  structRef.x = 42;
  assert(xRef.* == 42);

  let eitherRef: (either Yes(int), No)* = .Yes(3).&;

  let yesValue: int = eitherRef.asYes()!.value;
  let yesRef: typeOf(eitherRef).value.Yes* = eitherRef.asYes()!;

  assert(yesRef.value == 3);
  assert(yesRef.value*.* == 3);
  assert(yesValue == 3);

  referenceSet(eitherRef.asYes()!.value*, -3);
  assert(yesRef.value == -3);
  assert(yesRef.value*.* == -3);
  assert(eitherRef.asYes()!.value == -3);

  // no restrictions on lhs except that it has to be a pointer,
  // this in conjunction with let* will mean we have pointers for
  // simple mutable ints, and should mean we can evaluate the lhs
  // of assignments as a normal expression
  // <any ptr> <- <expr>

  let structOptRef: { x: int }*? = .Some({ x: 42 }.&);

  if structOptRef is .Some(x) {
    assert(x.x == 42);
    x.x = 43;
    assert(x.x == 43);
  } else {
    println("None")
  };

  0
}
