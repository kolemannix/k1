// Only code that is necessary for the compiler's operation
// belongs in this file

deftype unit = builtin
deftype char = builtin
deftype bool = builtin
deftype never = builtin
deftype Pointer = builtin

deftype f32 = builtin
deftype f64 = builtin

deftype Buffer[T] = { len: u64, data: Pointer }

deftype List[T] = { len: u64, private buffer: Buffer[T] }
deftype string = { buffer: Buffer[char] }

deftype Opt[T] = either None, Some(T)

deftype CompilerSourceLoc = { filename: string, line: u64 }

deftype Ordering = either Less, Equal, Greater

deftype Result[T, E] = either Ok(T), Err(E)

deftype alias int = i64
deftype alias uint = u64
deftype alias byte = u8

// Must have ability id 0
ability Equals {
  fn equals(self: Self, other: Self): bool
}

// Must have ability id 1
ability Show {
  // TODO: make this use an allocator. How does it get passed conveniently?
  fn show(self: Self): string
}

// TODO: a harness main that sets up the allocator
// fn main(): i32 {
//   let allocator = Allocator/initDefault();
//   
// }

intern fn sizeOf[T](): u64
intern fn sizeOfStride[T](): u64
intern fn alignOf[T](): u64

ns compiler {
  intern fn location(): CompilerSourceLoc
}

ability Bitwise {
  fn bitNot(self: Self): Self
  fn bitAnd(self: Self, other: Self): Self
  fn bitOr(self: Self, other: Self): Self
  fn xor(self: Self, other: Self): Self
  fn shiftLeft(self: Self, other: Self): Self
  fn shiftRight(self: Self, other: Self): Self
}

ability Comparable {
  fn compare(self: Self, other: Self): Ordering
}

ability Unwrap[impl Inner] {
  fn hasValue(self: Self): bool
  fn unwrap(self: Self): Inner
  fn make(inner: Inner): Self
}

ability Try[impl T, impl E] {
  // DO NOT REORDER `try` internal operation expects
  // makeError to be first! (FIXME)
  fn makeError(e: E): Self
  fn makeOk(t: T): Self

  fn isOk(self: Self): bool
  fn getError(self: Self): E
  fn getOk(self: Self): T
}

ability Iterator[impl Item] {
  fn next(self: Self*): Item?
  fn sizeHint(self: Self): { atLeast: u64, atMost: u64? }
  fn advanceBy(self: Self*, n: u64): unit
  fn nth(self: Self*, n: u64): Item?
}

ability Iterable[impl Item, impl I: Iterator[Item = Item]] {
  fn iterator(self: Self): I
}

impl[S, F] Try[T = S, E = F] for Result[S, F] {
  fn makeError(e: E): Self   { .Err(e) }
  fn makeOk(t: T): Self { .Ok(t) }

  fn isOk(self: Self): bool { self is .Ok(_) }
  fn getOk(self: Self): T  { self.asOk().!.value }
  fn getError(self: Self): E { self.asErr().!.value }
}

// inline fn unwrap_or[U, V: Unwrap[Inner = U]](v: V, backup: int): U {
//   if v.hasValue() v.unwrap() else backup
// }


ns bool {
  intern fn negated(self: bool): bool
}
