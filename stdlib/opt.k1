ns Opt {
  fn hasValue[T](self: T?): bool {
    self is .Some(_)
  }

  fn get[T](self: T?): T {
    if self is .Some(t) t else {
      crash("Opt.get on None")
    }
  }

  // I'm leaving this separate function here 
  // because at one point it exercised a really weird compiler bug
  fn opt_equals[T](a: Opt[T], b: Opt[T]): bool where T: Equals {
    if a is .Some(at) {
      if b is .Some(bt) at == bt else false
    } else {
      b is .None
    }
  }

}

// Convenience constructors in the global scope for Opt instances
fn none[T](): Opt[T].None { Opt.None[T] }
fn some[T](value: T): Opt[T].Some { Opt.Some[T](value) }


impl[T: Equals] Equals for Opt[T] {
  fn equals(self: Opt[T], other: Opt[T]): bool {
    Opt/opt_equals(self, other)
  }
}

impl[T] Unwrap[Inner = T] for Opt[T] {
  fn hasValue(self: Opt[T]): bool { self.hasValue() }
  fn unwrap(self: Opt[T]): T { self.get() }
}
