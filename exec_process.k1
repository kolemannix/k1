// Disclaimer: Super claude-y sloppy but working fork/execve example
// What's cool is that claude got here just by following compiler errors and reading the core lib
// I didn't even consider that **char was valid k1 syntax and did the expected thing.

// Process execution wrapper for K1  
// Raw execve-based implementation

// dead #if but could be done
#if core/k1/OS_POSIX

// POSIX system call extern declarations
extern("fork") fn fork(): i32
extern("execve") fn execve(path: ptr, argv: **char, envp: **char): i32
extern("waitpid") fn waitpid(pid: i32, status: *mut i32, options: i32): i32

// Convert View[string] to null-terminated **char array for execve  
fn makeArgv(context alloc: mem/AllocMode)(program: string, args: View[string]): **char {
    let totalArgs = 1 + args.len() + 1; // program + args + null terminator
    let argv: **char = alloc.alloc(
      size = totalArgs * types/sizeOf[ptr](),
      align = types/alignOf[ptr]()
    ).as();
    
    // Set program name as argv[0] 
    let progCStr = program.toCString();
    let argv_ptr = argv.as[*mut ptr];
    argv_ptr <- progCStr.ptr;
    
    // Set arguments
    let i = 0;
    while i < args.len() {
        let argCStr = args.get(i).toCString();
        let arg_slot = ptr/refAtIndex[ptr](argv.as[ptr], i + 1);
        arg_slot <- argCStr.ptr;
        i := i + 1;
    };
    
    // Null terminate
    let null_slot = ptr/refAtIndex[ptr](argv.as[ptr], totalArgs - 1);
    null_slot <- ptr/NULL;
    
    argv
}

fn runCommand(context alloc: mem/AllocMode)(program: string, args: View[string]): Result[i32, {}] {
    let progCStr = program.toCString();
    let argv = makeArgv(program, args);
    let envp = ptr/NULL.as[**char]; // Use current environment
    
    let pid = fork();
    
    if pid == 0 {
        // Child process - exec the command
        execve(progCStr.ptr, argv, envp);
        crash("execve failed; TODO check errno");
    } else if pid > 0 {
        // Parent process - wait for child
        let* status: *mut i32 = 0;
        waitpid(pid, status, 0);
        .Ok(status.*);
    } else {
        // Fork failed
        .Err(())
    }
}

fn testPosix() {
    println("Testing process execution...");
    //let context(impl Alloc) temp = mem/AllocMode.Arena;
    let context temp = mem/AllocMode.Arena;
    
    // Test 1: Simple echo command
    let echoStatus = runCommand(program = "/bin/echo", args = ["hello", "world"]).!;
    println("Echo exit status: {echoStatus}");
    
    // Test 2: List current directory  
    let lsStatus = runCommand(program = "/bin/ls", args = []).!;
    println("Ls exit status: {lsStatus}");
    
    // Test 3: Test command that should fail
    let failStatus = runCommand(program = "/nonexistent", args = []);
    println("Nonexistent command isOk(): {failStatus.isOk()}");
}

fn testExecProcess() {
  #if core/k1/OS_POSIX {
    testPosix()
  } else {
    println("Process execution only supported on POSIX systems")
  }
}
