ability Iterator[impl Item] {
  fn next(self: Self*): Item?
}
impl[T] Iterator[Item = T] for ListIterator[T] {
  fn next(self: ListIterator[T]*): Item? { 
    let ret = some(self.l.get(self.pos));
    if self.pos < self.l.len {
      self.pos* <- self.pos + 1;
      ret
    } else .None
  }
}

impl Show for ListIterator[int] {
  fn show(self: Self): string { crash("") }
}

ability Iterable[impl IItem, impl I: Iterator[Item = IItem]] {
  fn iter(self: Self): I
}
impl Iterable[IItem = int, I = ListIterator[int]] for List[int] {
  fn iter(self: List[int]): I {
    newListIterator(self)
  }
}
// impl[T] Iterable[I = ListIterator[T]] for List[T] {
//   fn iter(self: List[int]): I {
//     newListIterator(self)
//   }
// }

impl Show for i64? {
  fn show(self: i64?): string { if self is .Some(i) "Some(\{i})" else "None" }
}

fn testIterator(): int {
  let l = [1,2,3];
  let* i: ListIterator[int]* = l.iter();
  let n: int? = i.next();
  printIt(i.next());
  printIt(i.next());
  printIt(i.next());
  printIt(i.next());
  0
}

deftype ListIterator[T] = {
  l: List[T],
  pos: u64
}

fn newListIterator[T](l: List[T]): ListIterator[T] {
  { l, pos: 0 }
}

