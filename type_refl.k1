ns type_refl {
  deftype Point3[T] = {
    // nocommit reject dupe field name in struct definition
    // z: T, y: T, z: T
    x: T, y: T, z: T
  }
  
  use core/types/TypeSchema
  use core/types/typeSchema
  use core/types/typeId
  use core/types/typeName

  fn getTypeSchema[T](): TypeSchema { typeSchema(typeId[T]()) }
  
  fn printStructShape[T](): string {
    require getTypeSchema[T]() is .Struct({ fields }) else { return("") };
    let* sb = core/StringBuilder/new();
    let name = typeName[T]();
    sb.putString("--- Struct \{name} ---\n");
    for field in fields do {
      sb.putString(field.name);
      sb.putString(": TypeId(");
      // Should use 'Writer' ability
      sb.putString(field.typeId.show());
      sb.putString(")\n");
    };
    sb.build()
  }
  
  fn test(): unit {
  
    // nocommit: Parsing bug
    // assert(unitSchema is TypeSchema.Unit);
    assert(getTypeSchema[unit]() is .Unit);
    assert(getTypeSchema[u8]()   is .Int(.U8));
    assert(getTypeSchema[u16]()  is .Int(.U16));
    assert(getTypeSchema[u32]()  is .Int(.U32));
    assert(getTypeSchema[u64]()  is .Int(.U64));
    assert(getTypeSchema[i8]()   is .Int(.I8));
    assert(getTypeSchema[i16]()  is .Int(.I16));
    assert(getTypeSchema[i32]()  is .Int(.I32));
    assert(getTypeSchema[i64]()  is .Int(.I64));
    let pointByteSchema = getTypeSchema[Point3[u8]]();
    require pointByteSchema is .Struct({ fields }) else { crash("") };
    assertEquals(fields.len, 3);
    assert(getTypeSchema[i32*]() is .Reference(_));
    assertEquals(
      getTypeSchema[i32*]().asReference().!.value.innerTypeId,
      typeId[i32]()
    );
    assertEquals(
      getTypeSchema[bool**]().asReference().!.value.innerTypeId,
      typeId[bool*]()
    );

    assert(getTypeSchema[either Yes]()  is .Int(.I64));
    //assert(getTypeSchema[either Yes, No, MaybeSo(string)]()  is .Int(.I64));

    assert(getTypeSchema[\(int) -> int]() is .Other("function"));

    //println(printStructShape[Point3[u8]]());
    //println(printStructShape[TypeSchema.Struct.value]());
    //println(printStructShape[TypeSchema.Either]());
  
    ()
  }
}

fn main(): i32 {
  test();
  0
}
