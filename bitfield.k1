//deftype A = bitfield(u8) { F1: 1, F2: 1, F3: 1, U5: 5 }
let MODULE_INFO: core/k1/ModuleManifest = {
  let* m = core/mem/zeroed[core/k1/ModuleManifest]();
  m.kind* <- .Library;
  m.*
};

ns pre {
  fn intWidthForBits(bits: size): size {
    if bits <= 8 8
    else if bits <= 16 16
    else if bits <= 32 32
    else if bits <= 64 64
    else crash("Too many bits: {bits}")
  }
  fn bitfield[Base](typeName: string, members: View[{ name: string, bits: size }]): string {
    use core/StringBuilder;
    use meta/CodeWriter;
    let baseTypeId: u64 = types/typeId[Base]();
    let base = types/typeSchema(baseTypeId);
    require base is .Int(intKind) else { return("Base should be an int") };
    let totalBits = intKind.bitWidth();
    let baseName = types/typeName(baseTypeId);

    let* code = StringBuilder/new();
    // Could also use typeFromId; but I like the short name and we're restricted it u{n} here
    code.line("deftype {typeName} = {{ bits: {baseName} }");

    code.line("ns {typeName} {{");

    // Let Masks (I can also store inverse mask strings here: 0b111...)
    let* bitIndex = 0;
    let memberInfo: List[
    { mask: usize, invMask: usize, typeWidth: size, rawValue: usize, offset: size, nameCap: string }] = List/fromMap(members, \member. {
      let bits = member.bits;
      if bitIndex.* + bits > totalBits crash("Too big: {bitIndex.* + bits}");
      let rawValue = u64/bitmaskLow(bits);
      let typeWidth = intWidthForBits(bits);
      let nameCap = member.name.capitalizeAscii();
      let mask = rawValue << bitIndex.*.as();
      let offset = bitIndex.*;
      let sizeMask = u64/bitmaskLow(typeWidth);
      let invMask = mask.bitNot().bitAnd(sizeMask);

      // println("{member.name}: typeWidth: {typeWidth}");
      // println("{member.name}: raw value: {rawValue}");
      // println("{member.name}: mask: {mask}");
      // println("sizeMask: {sizeMask}");
      // println("invMask: {invMask}, bits: {invMaskBits}");
      bitIndex <- bitIndex.* + bits;

      // mask: the positioned mask; 0b100
      // rawValue: the mask shifted to the start, the 'magnitude' of the used bits
      // offset: the bit pos that the mask starts at; where the value lives
      { mask, invMask, typeWidth, rawValue, offset, nameCap }
    });

    for members {
      let info = memberInfo.get(itIndex);
      code.line("  let {it.name}Mask: {baseName} = {info.mask};");
    };

    code.line("  let zero: {typeName} = {{ bits: 0 };");

    for members {
      let info = memberInfo.get(itIndex);
      let nameCap = info.nameCap;
      let isBool = it.bits == 1;
      let fieldType = if isBool "bool" else "u{info.typeWidth}";

      // Getter
      code.line("  fn get{nameCap}(self: {typeName}): {fieldType} {{");

      code.line("    let bits: {baseName} = self.bits;");
      code.line("    let shifted: {baseName} = bits.shiftRight({info.offset});");
      code.line("    let cleared: {baseName} = shifted.bitAnd({info.rawValue});");
      if isBool {
        code.line("    cleared == 1")
      } else {
        code.line("    cleared.as[{fieldType}]");
      };

      code.line("  }"); // End Getter

      // Setter
      code.line("  fn set{nameCap}(self: {typeName}, value: {fieldType}): {typeName} {{");
      if isBool {
        code.line("    let maskedValue = (value.as_u8());")
      } else {
        code.line("    let maskedValue: {baseName} = value.bitAnd({info.rawValue});")
      };
      let clearMask = info.invMask;
      code.line("    let clearedBits: {baseName} = self.bits.bitAnd({clearMask});");
      code.line("    let insertedBits: {baseName} = clearedBits.bitOr(maskedValue.shiftLeft({info.offset}));");
      code.line("    {{ bits: insertedBits }");
      code.line("  }"); // End setter
    };

    code.line("}"); // End ns

    let* printBody = StringBuilder/new();
    for members {
      let info = memberInfo.get(itIndex);
      let getName = "get{info.nameCap}";
      let last = itIndex + 1 == members.len();
      let sep = if last "" else ",";
      printBody.line(`    w.writeString("{it.name}={{self.{getName}()}{sep}");`);
    };
    code.implPrint(typeName, printBody.build(), indent = 0);

    let s = code.build();
    println(s);
    s
  }
}

// TODO: Make the struct version work with static types!
// #meta pre/deftypeBitfield[u8, _]("ShipFlags", { shielded: 1, cloaked: 1, damaged: 1, sector_id: 5, foo: 8 })
#meta pre/bitfield[u16]("FlagsAuto", 
[{ name: "shielded", bits: 1 },
 { name: "cloaked",  bits: 1 },
 { name: "damaged",  bits: 1 },
 { name: "sectorId", bits: 5 },
 { name: "foo",      bits: 8 }
 ])

#static {
  let y: FlagsAuto = { bits: 0b1111_0000_1000_1101 };
  let x: FlagsAuto = FlagsAuto/zero.setShielded(true).setDamaged(true).setSectorId(17).setFoo(0b1111_0000);
  //x.setshielded(true);
  println("x: {x}");
  println("y: {y}");
  assertEquals(y.getShielded(), x.getShielded());
  assertEquals(y.getCloaked(), x.getCloaked());
  assertEquals(y.getDamaged(), x.getDamaged());
  assertEquals(y.getSectorId(), x.getSectorId());
}
