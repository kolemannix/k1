let MODULE_INFO: core/k1/ModuleManifest = {
    kind: .Library,
    deps: "",
};

let n: uword = 255;
let x: uword = 256;

fn isPow2(x: uword): bool { (x - 1) | Bitwise/bitAnd(x) == 0 }

fn defineSoA[T](name: string): string {
  require types/getTypeSchema[T]() is .Struct({ fields }) else
    crash("Its called a STRUCT of arrays for a reason");
  let code = core/StringBuilder/new();
  code.putString("deftype {name} = {{\n");
  for f in fields do {
    code.putString("  {f.name}_ARRAY: List[typeFromId({f.typeId})],\n");
  };
  code.putString("}\n");
  code.putString("ns {name} {{\n");
  code.putString(`fn get[T](self: {name}[T], index: uword): T {{`);
  for f in fields do {
    code.putString(`let f{index} = self.{f.name}_ARRAY.get(index);\n`)
  };
  code.putString("}\n");
  code.build()
}

#meta {
  let name1 = "1";
  let name2 = "2";
  let a = "ns Secret {{ fn secret{name1}(): int {{ 42 } }\n";
  let b = "ns Secret {{ fn secret{name2}(): int {{ 43 } }\n";
  "{a}{b}"
}

#meta {
  "deftype Frob = {{ b: bool }"
}

#meta {
  "ability Named {{ fn getName(self: Self): string }"
}

#meta {
  `impl Named for Frob {{
    fn getName(self: Self): string {{ if self.b "Bob" else "Joe" }
  }`
}

#static {
  let frob: Frob = { b: false };

  println("frob name: {frob.getName()}");
  println("isPow2(n): {isPow2(n)}");
  println("isPow2(x): {isPow2(x)}");
  println("secret1: {Secret/secret1()}");
  println("secret2: {Secret/secret2()}");

  println("SoA 1:\n{defineSoA[{ x: u32, y: u32 }](`p2`)}");

  crash("bye bye")

}
// nocommit(1) defn conditions
// #if true #static { println("Hello, true") } 
// #if false #static { println("Hello, false") } 
