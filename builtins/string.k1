// TODO: CString type
// type alias opaque CString = Pointer
// namespace CString { }

namespace string {

  fn getRef(self: string, index: u64): char* {
    if index >= self.len {
      crash("string index out of bounds: ".concat(index.show()))
    };
    let charRef: char* = self.data.refAtIndex(index);
    charRef
  }

  fn get(self: string, index: u64): char {
    let charRef: char* = self.getRef(index);
    charRef.*
  }
  fn set(self: string, index: u64, value: char): unit {
    let charRef: char* = self.getRef(index);
    referenceSet(charRef, value)
  }

  fn fromBytes(bytes: Array[byte]): string {
    assert(sizeOf[char]() == sizeOf[byte]());
    let copied = bytes.cloned();
    { len: copied.len, data: copied.data }
  }

  fn fromChars(bytes: Array[char]): string {
    let copied = bytes.cloned();
    { len: copied.len, data: copied.data }
  }

  fn isEmpty(self: string): bool {
    self.len == 0
  }

  fn indexOf(self: string, c: char): i64 {
    let mut i: u64 = 0;
    while i < self.len {
      if self.get(i) == c {
        return(i as i64);
      };
      i = i + 1;
    };
    -1
  }

  fn concat(self: string, other: string): string {
    let new_length = self.len + other.len;
    let* copied = Array::withCapacity[char](new_length);

    libc::memcpy(copied.data, self.data, self.len);

    let offset = copied.data as u64 + self.len;
    libc::memcpy(offset as Pointer, other.data, other.len);

    copied.len = new_length;
    fromChars(copied)
  }

  fn appendChar(self: string, c: char): string {
    let new_length = self.len + 1;

    let* copied = Array::withCapacity[char](new_length);
    copied.len = new_length;

    libc::memcpy(copied.data, self.data, self.len);
    copied.set(self.len, c);

    fromChars(copied)
  }

  fn splitByChar(self: string, delim: char): Array[string] {
    let* results = Array::new[Array[char]]();
    let* accum = Array::new[char]();
    // Note(stdlib slow): TODO: use ranges instead to make this zero-copy!!
    //                    We can point to the old string instead of building up new ones
    for c in self do {
      if c == delim {
        if accum.*.nonEmpty() {
          results.push(accum);
          referenceSet(accum, Array::new[char]())
        }
      } else {
        accum.push(c);
      };
    };
    if accum.*.nonEmpty() {
      results.push(accum);
    };

    for buf in results.* yield {
      string::fromChars(buf)
    }
  }

  fn indexOfString(self: string, target: string): u64? {
    let mut i: u64 = 0;
    while i < self.len {
      if i + target.len >= self.len {
        return(.None)
      };
      let sub = self.substring(i, i + target.len);
      if sub == target { return(.Some(i)) };
      i = i + 1;
    };
    .None
  }

  fn substring(self: string, start: u64, end: u64): string {
    if start >= self.len or start < 0 {
      crash("substring start index out of bounds: ".concat(start.show()))
    };
    let end = if end >= self.len self.len else end;
    if end < start {
      return("")
    };
    let newLen = end - start;
    let newDataU64 = (self.data as u64) + (sizeOf[char]() * start);
    let newData = newDataU64 as Pointer;
    { len: newLen, data: newData }
  }

  fn startsWith(self: string, other: string): bool {
    self.substring(0, other.len) == other
  }

  fn toCString(self: string): Pointer {
    self.appendChar('\0').data
  }

  fn toInt(self: string): int? {
    if self.isEmpty() { return(.None) };

    let neg = self.get(0) == '-';
    let mut i: u64 = if neg 1 else 0;
    let mut total: u64 = 0;
    while i < self.len {
      let c = self.get(i);
      let digit = c.toAsciiDigit();
      if digit is .Some(digit) {
        total = (total * 10) + digit as u64;
      } else {
        return(.None);
      };
      i = i + 1;
    };

    some(
      if neg { (total as i64) * -1 } else { total as i64 }
    )
  }

}

impl Equals for string {
  fn equals(self: string, that: string): bool {
    if self.len != that.len { return(false) };
    let compareResult = libc::memcmp(self.data, that.data, self.len);
    compareResult == 0
  }
}

impl Equals for Array[string] {
  fn equals(self: Array[string], other: Array[string]): bool {
    if self.len != other.len {
      false
    } else {
      let mut i: u64 = 0;
      while i < self.len {
        if self.get(i) != other.get(i) {
          return(false);
        };
        i = i + 1;
      };
      true
    }
  }
}

// One day? impl Show for Array[T] ???
// Note(stdlib slow): Need efficient string building
impl Show for Array[string] {
  fn show(self: Array[string]): string {
    let mut builder: string = "[";
    for s in self do {
      builder = builder.concat(s);
      let last = it_index == self.len - 1;
      if not last {
        builder = builder.concat(", ");
      };
    };
    builder.concat("]")
  }
}

impl Show for string {
  fn show(self: string): string { self }
}

impl Equals for Opt[string] {
  fn equals(self: Opt[string], other: Opt[string]): bool {
    opt_equals(self, other)
  }
}
