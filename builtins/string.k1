// TODO: CString type
// type alias opaque CString = Pointer
// namespace CString { }

namespace string {

  fn getRef(self: string, index: u64): char* {
    if index >= self.len {
      crash("string index out of bounds")
    };
    val charRef: char* = self.data.refAtIndex(index);
    charRef
  }

  fn get(self: string, index: u64): char {
    val charRef: char* = self.getRef(index);
    *charRef
  }
  fn set(self: string, index: u64, value: char): unit {
    val charRef: char* = self.getRef(index);
    referenceSet(charRef, value)
  }

  fn fromChars(bytes: Array[char]): string {
    { len: bytes.len, data: bytes.data }
  }

  fn indexOf(self: string, c: char): i64 {
    mut i: u64 = 0;
    while i < self.len {
      if self.get(i) == c {
        return(i as i64);
      };
      i = i + 1;
    };
    -1
  }

  fn concat(self: string, other: string): string {
    val new_length = self.len + other.len;
    val copied = &Array::new[char](new_length);

    libc::memcpy(copied.data, self.data, self.len);

    val offset = copied.data as u64 + self.len;
    libc::memcpy(offset as Pointer, other.data, other.len);

    copied.len = new_length;
    fromChars(copied)
  }

  fn appendChar(self: string, c: char): string {
    val new_length = self.len + 1;

    val copied = &Array::new[char](new_length);
    copied.len = new_length;

    libc::memcpy(copied.data, self.data, self.len);
    copied.set(self.len, c);

    fromChars(copied)
  }

  fn splitAtChar(self: string, delim: char): Array[string] {
    val results = &Array::new[Array[char]](0);
    for c in self do {
      if c == delim {
        results.push(Array::new[char](0));
      } else {
        if results.last() is .Some(s) {
          (&s).push(c)
        } else {
          results.push([c])
        };
      };
    };
    for buf in *results yield {
      string::fromChars(buf)
    }
  }

  fn toCString(self: string): Pointer {
    self.concat('\0'.toString()).data
  }
}

impl Equals for string {
  intern fn equals(self: string, that: string): bool
}

impl Equals for Array[string] {
  fn equals(self: Array[string], other: Array[string]): bool {
    if self.len != other.len {
      false
    } else {
      mut i: u64 = 0;
      while i < self.len {
        if self.get(i) != other.get(i) {
          return(false);
        };
        i = i + 1;
      };
      true
    }
  }
}
