// This table exercises:
// - Generics
// - References/pointers
// - Structs and enums (Option type)
// - Loops and control flow
// - Basic numeric operations
// - String handling
// - Array operations

//deftype Entry[V] = either Empty, Deleted, Occupied(V)
deftype HashMap[V] = {
  size: u64,
  entries: Array[{ key: string, value: V }?],
}

fn fnv1a_hash(key: string): u64 {
  val FNV_PRIME: u64 = 1099511628211;
  val FNV_OFFSET: u64 = 14695981039346656037;
  mut hash_value = FNV_OFFSET;
  for c in key do {
    hash_value = Bitwise::xor(hash_value, c as u8 as u64);
    hash_value = hash_value * FNV_PRIME;
  };
  hash_value
}

namespace HashMap {

  deftype Entry[V] = { key: string, value: V }?

  fn _make[V](cap: u64): HashMap[V] {
    { size: 0, entries: Array::filled(cap, .None) }
  }

  fn new[V](): HashMap[V] {
    _make(0)
  }

  fn grow[V](self: HashMap[V]*): unit {
    val origSize = self.size;
    val oldEntries = self.entries;
    val newCap = if oldEntries.cap == 0 1: u64 else oldEntries.cap * 2;

    val newMap = _make[V](newCap);
    referenceSet(self, newMap);

    mut oldCount = 0: u64;
    for v in oldEntries do {
      if v is .Some(v) {
        oldCount = oldCount + 1;
        self.insert(v.key, v.value)
      }
    };
  }

  fn _computeIndex[V](self: HashMap[V]*, key: string): u64 {
    val hash = fnv1a_hash(key);
    val index = hash % self.entries.len;
    index
  }

  // Super naive fully linear probing
  fn _probe[V](self: HashMap[V], startIndex: u64): Entry[V]* {
    mut probeIndex = startIndex;
    loop {
      probeIndex = probeIndex + 1;
      if probeIndex == self.entries.len { probeIndex = 0 };

      val entryRef = self.entries.getRef(probeIndex);
      // TODO: match on reference
      if entryRef.* is .None {
        return(entryRef)
      }
    }
  }

  fn fillFactor[V](self: HashMap[V]): f32 {
    val fillDivisor = if self.entries.len == 0 1 as f32 else self.entries.len as f32;
    val fillNumerator = if self.size == 0 1.0 else self.size as f32;
    val fillFactor = fillNumerator / fillDivisor;
    fillFactor
  }

  fn insert[V](self: HashMap[V]*, key: string, value: V): unit {
    if self.fillFactor() > 0.7 {
      self.grow();
    };
    val index = self._computeIndex(key);
    val entryRef = self.entries.getRef(index);
    val entry = { key: key, value: value };
    switch entryRef.* {
      .None -> {
        referenceSet(entryRef, .Some(entry));
        self.size = self.size + 1;
      },
      .Some({ key: existingKey, value: _ }) -> {
        if existingKey == key {
          referenceSet(entryRef, .Some(entry));
        } else {
          val nextAvailableEntry = self._probe(index);
          referenceSet(nextAvailableEntry, .Some(entry));
          self.size = self.size + 1;
        }
      }
    };
  }

  fn get[V](self: HashMap[V]*, key: string): V? {
    val index = self._computeIndex(key);
    // println("index for \{key}: \{index}");
    val slot = self.entries.get(index);
    switch slot {
      .None -> .None,
      .Some({ key: existingKey, value: v }) -> {
        if existingKey == key {
          .Some(v)
        } else {
          mut probe_index = index;
          loop {
            probe_index = probe_index + 1;
            if probe_index == self.entries.len { probe_index = 0; };

            switch self.entries.get(probe_index) {
              .Some({ key: existingKey, value: value }) -> {
                if key == existingKey { break(.Some(value)) }
              },
              .None -> { break(Opt.None[V]) },
            }
          }
        }
      }
    };
  }

  // fn remove[V](self: HashMap[V]*, key: string): unit {
  // }

  fn dump[V](self: HashMap[V]): unit where V: Show {
    val capacity = self.entries.len;
    val size = self.size;
    println("Capacity: \{capacity}");
    println("Size: \{size}");
    println("");
    for self.entries do {
      printUInt(it_index);
      print(" ");
      switch it {
        , .None -> println("empty")
        , .Some({ key, value }) -> {
            print(key | string::concat(" -> ") | string::concat(value.show()) | string::concat('\n'.toString()));
        }
      }
    }
  }

}

fn test(size: u64): unit {
  val myMap: HashMap[int]* = HashMap::new().&;
  mut i = 0: i64;
  while i < size as i64 {
    myMap.insert(i.show(), i);
    i = i + 1;
  };
  assert(myMap.size == size);
  i = 0;
  while i < size as i64 {
    switch myMap.get(i.show()) {
      .None -> println("None for \{i}!!!"),
      .Some(v) -> assert(v == i),
    };
    i = i + 1;
  };
  myMap.*.dump();
}

fn main(): int {
  test(100000);
  0
}

fn randByte(): u8 {
  (libc::arc4random_uniform(26) + 65) as u8
}

fn randString(len: uint): string {
  val arr = Array::withCapacity[char](len).&;
  mut i: uint = 0;
  while i < len {
    arr.push(randByte() as char);
    i = i + 1;
  };
  string::fromChars(arr)
}
