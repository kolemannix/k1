deftype HashMap[V] = {
  size: u64,
  slots: Array[{ key: string, value: V }?],
}

fn fnv1a_hash(key: string): u64 {
  val FNV_PRIME: u64 = 1099511628211;
  val FNV_OFFSET: u64 = 14695981039346656037;
  mut hash_value = FNV_OFFSET;
  for c in key do {
    hash_value = Bitwise::xor(hash_value, c as u8 as u64);
    hash_value = hash_value * FNV_PRIME;
  };
  hash_value
}

namespace HashMap {

  fn _make[V](cap: u64): HashMap[V] {
    val slots: Array[{ key: string, value: V }?]* = Array::new(cap).&;
    mut i = 0: u64;
    while i < cap {
      slots.push(.None);
      i = i + 1;
    };
    { size: 0, slots: slots.* }
  }

  fn new[V](): HashMap[V] {
    _make(2)
  }

  fn grow[V](self: HashMap[V]*): unit where V: Show {
    val origSize = self.size;
    val oldSlots = self.slots;
    val newCap = oldSlots.cap * 2;
    println("growing to ".concat(newCap.show()));
    self.dump();

    val newMap = _make[V](newCap);
    referenceSet(self, newMap);

    mut oldCount = 0: u64;
    for v in oldSlots do {
      if v is .Some(v) {
        oldCount = oldCount + 1;
        self.insert(v.key, v.value)
      }
    };
    val newSize = self.size;
    if oldCount != origSize {
      println("Bad before grow; size lied; got actual ".concat(oldCount.show()))
    };
    if origSize != newSize {
      println("*****************************bad grow");
      println("origSize: ".concat(origSize.show()));
      println("newSize: ".concat(newSize.show()));
      self.dump();
    }
  }

  fn insert[V](self: HashMap[V]*, key: string, value: V): unit where V: Show {
    val fillFactor = self.size as f32 / self.slots.len as f32;
    if fillFactor > 0.7 {
      self.grow();
    };
    val hash = fnv1a_hash(key);
    val index = hash % self.slots.len;
    val elem = { key: key, value: value };
    val slot = self.slots.get(index);
    val sizeBefore = self.size;
    switch slot {
      .None -> {
        self.slots.set(index, .Some(elem));
        self.size = self.size + 1;
      },
      .Some({ key: existingKey, value: _ }) -> {
        if existingKey == key {
          self.slots.set(index, .Some(elem));
        } else {
          // Super naive fully linear probing
          mut probe_index = index;
          mut done = false;
          while not done {
            probe_index = probe_index + 1;
            if probe_index == self.slots.len {
              probe_index = 0;
            };
            // nocommit: Disallow variable patterns in 'is'?
            //           Disallow capital variables?
            /// if self.slots.get(probe_index) is None {
            if self.slots.get(probe_index) is .None {
              self.slots.set(probe_index, .Some(elem));
              self.size = self.size + 1;
              done = true;
            };
          };
        }
      }
    };
  }

  fn get[V](self: HashMap[V]*, key: string): V? {
    val hash = fnv1a_hash(key);
    val index = hash % self.slots.len;
    val slot = self.slots.get(index);
    switch slot {
      .None -> .None,
      .Some({ key: existingKey, value: v }) -> {
        if existingKey == key {
          .Some(v)
        } else {
          mut probe_index = index;
          mut retVal: V? = .None;

          // todo: Return from inside loop? or break w/ value
          mut done = false;
          while not done {
            probe_index = probe_index + 1;
            if probe_index == self.slots.len {
              probe_index = 0;
            };
            if self.slots.get(probe_index) is .Some({ key: existingKey, value: v }) {
              if existingKey == key {
                retVal = .Some(v);
                done = true;
              }
            };
          };
          retVal
        }
      }
    };
  }

  fn dump[V](self: HashMap[V]): unit where V: Show {
    print("Capacity: ");
    printUInt(self.slots.cap);
    println("");
    for self.slots do {
      printUInt(it_index);
      print(" ");
      switch it {
        , .None -> println("empty")
        , .Some({ key, value }) -> {
            print(key | string::concat(" -> ") | string::concat(value.show()) | string::concat('\n'.toString()));
        }
      }
    }
  }

}


fn test(): unit {
  val myMap: HashMap[int]* = HashMap::new().&;
  mut i = 0: i64;
  val size = 256: u64;
  while i < size as i64 {
    myMap.insert(i.show(), i);
    i = i + 1;
  };
  assert(myMap.size == size);
  i = 0;
  while i < size as i64 {
    assert(myMap.get(i.show())! == i);
    i = i + 1;
  };
  myMap.*.dump();
}

fn randByte(): u8 {
  (libc::arc4random_uniform(26) + 65) as u8
}

fn randString(len: uint): string {
  val arr = Array::new[char](len).&;
  mut i: uint = 0;
  while i < len {
    arr.push(randByte() as char);
    i = i + 1;
  };
  string::fromChars(arr)
}

fn main(): int {
  test();
  // printUInt(42);
  // printInt(42);
  // printInt(-42);
  0
}
