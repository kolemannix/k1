fn map[T, U](a: Array[T], f: \T -> U): Array[U] {
  for i in a yield { f(i) }
}

fn filter[T](a: Array[T], f: \T -> bool): Array[T] {
  val keep = &Array::new[T](0);
  for i in a do { if f(i) keep.push(i) };
  keep
}

fn staticAddOne(x: int): int { x + 1 }

// fn __clos_addOne(x: int, env: { closedOver: int }*): int { x + { (*env).closedOver } }

fn main(): int {
  val closedOver: int = 3;

  val addOne = \x: int -> x + 1;
  val addOne2 = addOne;
  val addOne3 = \i: int -> staticAddOne(i);

  printInt(addOne(1));
  printInt(addOne2(2));
  printInt(addOne3(3));


  // round 4
  val result = [1,2,3,5,6,7,8] 
  | map(\x: int -> x + 1) 
  | filter(\x: int -> x % 2 == 0);

  for i in result do {
    println(i.show())
  };
  
  0
}
