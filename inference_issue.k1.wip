fn some[U](value: U): Opt[U].Some { Opt.Some[U](value) }
fn identity[T](value: T): T { value }
fn wrapIt[T](t: T): T? {
  some(identity(identity(identity(t))))
  wrapIt.T := ?
  some.U := ?
  Opt[U] =:= Opt[T]
  some.U := wrapIt.T

  identity(identity(identity(t))): wrapIt.T
  identity.T =:= wrapIt.T

  identity(identity(t)): wrapIt.T
  identity.T =:= wrapIt.T

  identity(t): wrapIt.T
  identity.T =:= wrapIt.T

  let x = identity(identity(11));
  outer identity.T := ?
  ret: nothing
  arg 1: identity(11): outeridentity.T (Key: don't consider it solved, just add a link or constraint! This is what lets us send information up and down!)
  inner identity.T := ?
  11: int
  inner identity.T := int
  arg1: int: outeridentity.T


  Expr: identity[?1](identity(11)): <none>
    Ret type (poly true): identity.T
constraints: []
    intro ?1
    vars: identity.T =:= ?1
    Expr: identity[?2](11): ?2
constraints: [?1 = ?2]
        Expr: 11: ?2
constraints: [?1 = ?2, int = ?2]
    ?1 = int
    ?2 = int






  
}

fn start(args: Buffer[string]): i32? {
  // This does not infer to i32 because we solve that some.T := i64 first
  // because we look at just the argument and parameter, which is enough since a hintless integer gives i64
  // and we never use the return type. However, if we use return type first, we end up with the
  // 'identity(identity(x))' bug again
  // I could actually just solve this with a 'wider' integer type or like 'LITERAL' that can coerce to any integer type
  #debug some(0)
  // Whereas this works because there's no separate inference eval, we just find the enum
  // and do substitutions

  // I could add a constraint from the expected type!
  // What if I use the return type if its _not_ an unsolved type variable? I think name collisions are possible unfortunately (wrapIt.T vs identity.T)
  // Hmmmmmmm
  //.Some(0)
}

fn main(argCount: u32, args: Pointer): i32 {
  let args = sys/parseMainArgs(argCount, args);
  start(args).!;
  0
}
