use core/Writer
use types/TypeSchema
use types/typeSchema

fn _writeJsonFromSchema(name: string, typeId: u64): unit {
  switch typeSchema(typeId) {
    .Struct(s) -> {
      #emit w.writeChar('{');
      for f in s.fields do {
        let fName = f.name;

        let fieldLetName = "_{name}{fName}";

        #emitstring "let {fieldLetName} = {name}.{fName}";
        #emit w.writeChar('"');
        #emitstring "w.writeString(\"{fName}\")";
        #emit w.writeString("\":");
        
        _writeJsonFromSchema(fieldLetName, f.typeId);
        let last = itIndex == s.fields.len - 1;
        if not last {
          #emit w.writeString(",");
        }
      };
      #emit w.writeChar('}');
    },
    .Unit -> #emit w.writeString("\"unit\""),
    .Bool -> {
      #emitstring "w.writeString(if {name} \"true\" else \"false\")" 
    },
    .Word(_) or .Int(_) -> #emitstring "{name}.printTo(w)",
    .Either(_) -> { 
      let tName = types/typeName(typeId);
      crash("Cannot yet create a JSON writer for either: {tName}")
    },
    _ -> {
      #emit w.writeString("\"other\"")
    }
  }
}

fn writeJson[T, W: Writer](context w: W*)(t: T): unit {
  // To say dont even typecheck this function generically: "template fn"
  #static {
    let typeId = types/typeId[T]();
    _writeJsonFromSchema("t", typeId);
  }
}

fn toJson[T](t: T): string {
  let* w = List/empty[char]();
  writeJson(context w)(t);
  let s = string/wrapList(w);
  println("Json: `{s}`");
  s
}

fn main(): i32 {
  let* w = List/empty[char]();

  toJson({ x: 1, y: 2 });
  toJson(some(1337));
  toJson(true);

  0
}
