use core/Writer
use types/TypeSchema
use types/typeSchema

fn _writeJsonFromSchema(name: string, typeId: u64): unit {
  use core/meta/emitLine;
  switch typeSchema(typeId) {
    .Struct(s) -> {
      emitLine(#code w.writeChar('{'));
      for f in s.fields do {

        let fieldLetName = "_{name}{f.name}";

        emitLine("let {fieldLetName} = {name}.{f.name}");
        emitLine(#code w.writeChar('"'));
        emitLine("w.writeString(\"{f.name}\")");
        emitLine(#code w.writeString("\":"));
        
        _writeJsonFromSchema(fieldLetName, f.typeId);
        let last = itIndex == s.fields.len - 1;
        if not last {
          emitLine(#code w.writeString(","));
        }
      };
      emitLine(#code w.writeChar('}'));
    },
    .Unit -> emitLine(#code w.writeString("\"unit\"")),
    .Bool -> {
      emitLine("w.writeString(if {name} \"true\" else \"false\")") 
      // #emitstring `w.writeString(if {name} "true" else "false")`
    },
    .Word(_) or .Int(_) -> emitLine("{name}.printTo(w)"),
    .Either(_) -> { 
      let tName = types/typeName(typeId);
      crash("Cannot yet create a JSON writer for either: {tName}")
    },
    _ -> {
      emitLine(#code w.writeString("\"other\""))
    }
  }
}

fn writeJson[T, W: Writer](context w: W*)(t: T): unit {
  // To say dont even typecheck this function generically: "template fn"
  // Or just the if below... But I think it'll be a common issue
  #meta {
    let typeId = types/typeId[T]();
    _writeJsonFromSchema("t", typeId);
  }
}

fn toJson[T](t: T): string {
  let* w = List/empty[char]();
  writeJson(context w)(t);
  let s = string/wrapList(w);
  println("Json: `{s}`");
  s
}

fn main(): i32 {
  let* w = List/empty[char]();

  toJson({ x: 1, y: 2 });
  //toJson(some(1337));
  toJson(true);

  0
}
