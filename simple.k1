fn foo(): i32 {
  let x = { x: 2, blub: mem/new(true) };
  x;
  crash("foo")
}

fn retu8(): u8 { 7 }
fn reti16(): i16 { -10 }
fn retf32(): f32 { -27.5 }

fn main(): i32 {
   let thePtr = #static { core/libc/malloc(64) as uword } ;
   eprintln("malloc was: {thePtr}");

   let theU8 = #static retu8();
   eprintln("u8 was: {theU8}");
   let theI16 = #static reti16();
   eprintln("i16 was: {theI16}");

   let thef32 = #static retf32();
   eprintln("f32 was: {thef32}");

   #static {
     let* buf = Array/zeroed[char, 1024uword]();
     let len = core/k1rt/snprintf_f64(
       buf.basePtr(), 1024, 3.14, places = 3
     );
     if len < 0 crash("");
     let chars = buf.asView().slice(0, len as uword);
     println("CHARS: {chars}");
   };

   core/sys/exit(0);
}

// The current string interpolation is lacking some elegance
// because it couples 2 things: specifying a list of writables, either strings or expressions,
// writing those to a Writer, and allocating a Writer.

// for example, you could imagine supplying your own writer to skip the intermediate string
// if you know you're going to stdout:
//fmt(stdout, "{1} {2} {} {}", [3, 4]);
// But this would require some sort of macro that I do not have
// I could also do just a magic builtin called `fmt` that is compiler-implemented
// Takes a Writer, a format string, and N args. But we're not that far from
// being able to do this in comptime userland. So I'm just going to wait
// until I have a final macro system, then move interpolation there.
// This way, it can be de-coupled from string construction if desired, but 
// also coupled if you do want a string for convenience

//deftype Expr = either FmtString(Parts), Other(string)
//macro fmt(writer: Expr, s: Expr, args: View[Expr]) {
//fn fmt[W: Writer, S: static FmtString, Args](writer: W, fmtString: S, args: Args): unit {
//  let* sb = StringBuilder/new();
//  let argsCount = 
//  for p in s.parts do { 
//    switch p {
//      .String(s) -> { 
//        // format("?.writeString(?)");
//        writer.printTo(sb); sb.writeString(".writeString("); s.printTo(sb); sb.writeString(")")  
//      },
//      .Expr(e) -> { e.printTo(sb); sb.writeString(".printTo("); writer.printTo(sb); sb.writeString(")") }
//    }
//  }
//}

