//let x: int = #static {
//  3 * 4
//};

fn main(): i32 {

  // Signed widen
  let x: u8 = 3;
  let x2: u64 = x;
  assertEquals(x2, 3);

  // Unsigned widen
  let x: i16 = 3;
  let x2: i64 = x;
  assertEquals(x2, 3);

  // Unsigned widen to signed
  let x: u32 = 3;
  let x2: i64 = x;
  assertEquals(x2, 3);
  
  0
}

// I think it compiles to a struct literal; { fmtStr: string, arg1: <t1>, arg2: <t2>, etc, etc, etc }

// The current string interpolation is lacking some elegance
// because it couples 2 things: specifying a list of writables, either strings or expressions,
// writing those to a Writer, and allocating a Writer.

// for example, you could imagine supplying your own writer to skip the intermediate string
// if you know you're going to stdout:
//fmt(stdout, "{1} {2} {} {}", [3, 4]);
// But this would require some sort of macro that I do not have
// I could also do just a magic builtin called `fmt` that is compiler-implemented
// Takes a Writer, a format string, and N args. But we're not that far from
// being able to do this in comptime userland. So I'm just going to wait
// until I have a final macro system, then move interpolation there.
// This way, it can be de-coupled from string construction if desired, but 
// also coupled if you do want a string for convenience

//deftype Expr = either FmtString(Parts), Other(string)
//macro fmt(writer: Expr, s: Expr, args: View[Expr]) {
//fn fmt[W: Writer, S: static FmtString, Args](writer: W, fmtString: S, args: Args): unit {
//  let* sb = StringBuilder/new();
//  let argsCount = 
//  for p in s.parts do { 
//    switch p {
//      .String(s) -> { 
//        // format("?.writeString(?)");
//        writer.printTo(sb); sb.writeString(".writeString("); s.printTo(sb); sb.writeString(")")  
//      },
//      .Expr(e) -> { e.printTo(sb); sb.writeString(".printTo("); writer.printTo(sb); sb.writeString(")") }
//    }
//  }
//}

