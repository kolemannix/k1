// Copyright (c) 2025 knix
// All rights reserved.

ns mem {

  // For now here's all I can do until I have dyn traits
  deftype Allocator = {
    malloc:  *(\(uword, uword) -> Pointer),
    zalloc:  *(\(uword, uword) -> Pointer),
    realloc: *(\(Pointer, uword, uword, uword) -> Pointer),
    free:    *(\(Pointer, uword, uword) -> unit),
  }

  fn virtualAlloc(size: uword): Pointer {
    // Workaround for not having implemented virtual alloc in the VM yet.
    if k1/IS_STATIC { alloc(size, 8) } else {
      let rw = posix/PROT_READ.bitOr(posix/PROT_WRITE);
      let privateAnon = posix/MAP_PRIVATE.bitOr(posix/MAP_ANON);
      let addr = posix/mmap(
        addr = Pointer/NULL,
        len = size,
        prot = rw,
        flags = privateAnon,
        fd = -1,
        offset = 0
      );
      if addr == (posix/MAP_FAILED as Pointer) crash("mmap failed");
      // todo Advise sequential
      // posix/madvise();
      addr
    }
  }

  fn virtualRelease(base: Pointer, len: uword): unit {
    if k1/IS_STATIC { free(base, len, 8) } else {
      let result = posix/munmap(base, len);
      if result == -1 crash("munmap of ptr {base} x {len} failed");
      ()
    }
  }

  deftype AllocMode = {
    kind: (either
      Current,
      SystemHeap,
      CustomHeap(*mut Allocator),
      TempBump,
      Bump(*mut Arena),
      Gc
    )
  }

  ns AllocMode {

    let SYSTEM_HEAP: AllocMode = { kind: .SystemHeap };
    let CURRENT: AllocMode = { kind: .Current };
    let TEMP: AllocMode = { kind: .TempBump };

    fn supportsRealloc(self: AllocMode): bool { switch self.kind {
      .Current -> crash("unreachable"),
      .SystemHeap or .CustomHeap(_) -> true,
      .TempBump or .Bump(_) -> false,
      .Gc -> false
    } }

    fn requiresFree(self: AllocMode): bool { switch self.kind {
      .Current -> crash("unreachable"),
      .SystemHeap -> true,
      .CustomHeap(_) -> true,
      .TempBump -> false,
      .Bump(_) -> false,
      .Gc -> false
    } }

    fn kindName(self: AllocMode): string { switch self.kind {
      .Current -> "current",
      .SystemHeap -> "system",
      .CustomHeap(_) -> "custom",
      .TempBump -> "temp_bump",
      .Bump(_) -> "custom_bump",
      .Gc -> "gc"
    } }
  }

  fn resolveMode(mode: AllocMode): AllocMode {
    switch mode.kind {
      .Current -> {
        let mode = mem/defaultAllocMode();
        if mode.kind is .Current { crash("currentAllocMode.kind is Current; this will never resolve") };
        mode
      },
      _ -> mode,
    }
  }

  // FIXME: Runtime branching.
  // We need more language enhancements to make this all
  // compile-time branching
  fn allocIn(mode: AllocMode, size: uword, align: uword): Pointer {
    let mode = resolveMode(mode);
    switch mode.kind {
      .Current -> { crash("unreachable") },
      .SystemHeap -> mem/allocZeroed(size, align),
      .CustomHeap(alloc) -> {
        let zalloc = alloc.*.zalloc;
        zalloc(size, align)
      },
      .Bump(bump) -> {
        bump.pushLayout(size, align)
      },
      .TempBump -> {
        mem/getTempArena().pushLayout(size, align)
      },
      .Gc -> {
        crash("Gc is unimplemented; plan to support w/ bdwgc")
      }
    }
  }

  fn newIn[T](mode: AllocMode, t: T): *mut T {
    let ptr = allocIn(mode, core/types/sizeOf[T](), core/types/alignOf[T]());
    let ref: *mut T = ptr.rw();
    ref <- t;
    ref
  }

  fn new[T](t: T): *mut T {
    newIn[T](AllocMode/CURRENT, t)
  }

  fn reallocIn(mode: AllocMode, oldPtr: Pointer, oldSize: uword, align: uword, newSize: uword): Pointer {
    let mode = resolveMode(mode);
    switch mode.kind {
      .Current -> { crash("unreachable") },
      .SystemHeap -> mem/realloc(oldPtr, oldSize, align, newSize),
      .CustomHeap(alloc) -> {
        let realloc = alloc.*.realloc;
        realloc(oldPtr, oldSize, align, newSize)
      },
      .Bump(bump) -> {
        crash("UnsupportedOperation: realloc")
      },
      .TempBump -> {
        crash("UnsupportedOperation: realloc")
      },
      .Gc -> {
        crash("UnsupportedOperation: realloc")
      }
    }
  }

  fn freeIn(mode: AllocMode, ptr: Pointer, size: uword, align: uword): unit {
    let mode = resolveMode(mode);
    switch mode.kind {
      .Current -> { crash("unreachable") },
      .SystemHeap -> mem/free(ptr, size, align),
      .CustomHeap(alloc) -> {
        let free = alloc.*.free;
        free(ptr, size, align)
      },
      .Bump(bump) -> {
        crash("UnsupportedOperation: free")
      },
      .TempBump -> {
        crash("UnsupportedOperation: free")
      },
      .Gc -> {
        crash("UnsupportedOperation: free")
      }
    }
  }

  let* tls _k1_tempArena: *mut Arena = zeroed[Arena]();

  let* tls _k1_currentAllocMode: *mut mem/AllocMode = AllocMode/SYSTEM_HEAP;

  // Eventually, we want 'push'/'pop' for allocMode
  fn setDefaultAllocMode(mode: mem/AllocMode): unit {
    _k1_currentAllocMode <- mode
  }
  fn defaultAllocMode(): mem/AllocMode {
    _k1_currentAllocMode.*
  }

  // Initialize on first get() is perfect
  fn initTempArena(): unit {
    if not _k1_tempArena.basePtr.isNull() {
      crash("Arena already initialized")
    };
    let a = Arena/default();
    _k1_tempArena <- a;
  }

  fn getTempArena(): *mut Arena {
    if _k1_tempArena.basePtr.isNull() { initTempArena() };
    _k1_tempArena
  }

}
