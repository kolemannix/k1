// Copyright (c) 2025 knix
// All rights reserved.

ns mem {

  // For now here's all I can do until I have dyn traits
  deftype Allocator = {
    malloc:  *(\(size, size) -> ptr),
    zalloc:  *(\(size, size) -> ptr),
    realloc: *(\(ptr, size, size, size) -> ptr),
    free:    *(\(ptr, size, size) -> empty),
  }

  fn virtualAlloc(size: size): ptr {
    let rw = posix/PROT_READ.bitOr(posix/PROT_WRITE);
    let privateAnon = posix/MAP_PRIVATE.bitOr(posix/MAP_ANON);
    let addr = posix/mmap(
      addr = ptr/NULL,
      len = size,
      prot = rw,
      flags = privateAnon,
      fd = -1i32,
      offset = 0
    );
    if addr == posix/MAP_FAILED.as[ptr] {
      libc/perror(ptr/NULL);
      crash("mmap failed");
    };
    addr
  }

  fn virtualRelease(base: ptr, len: size): empty {
    let result = posix/munmap(base, len);
    if result == -1 crash("munmap of ptr {base} x {len} failed");
    {}
  }

  deftype AllocMode = either
    Current,
    SystemHeap,
    CustomHeap(*mut Allocator),
    Arena,
    CustomArena(*mut Arena),
    Gc

  impl Print for AllocMode {
    fn printTo[W: Writer](self: Self, w: W) {
      w.writeString(self.kindName())
    }
  }

  ns AllocMode {

    fn supportsRealloc(self: AllocMode): bool { switch self {
      .Current -> crash("unreachable"),
      .SystemHeap or .CustomHeap(_) -> true,
      .Arena or .CustomArena(_) -> false,
      .Gc -> false
    } }

    fn requiresFree(self: AllocMode): bool { switch self {
      .Current -> crash("unreachable"),
      .SystemHeap -> true,
      .CustomHeap(_) -> true,
      .Arena -> false,
      .CustomArena(_) -> false,
      .Gc -> false
    } }

    fn kindName(self: AllocMode): string { switch self {
      .Current -> "current",
      .SystemHeap -> "system",
      .CustomHeap(_) -> "custom",
      .Arena -> "arena",
      .CustomArena(_) -> "custom_bump",
      .Gc -> "gc"
    } }

    fn resolve(self: AllocMode): AllocMode {
      switch self {
        .Current -> {
          let mode = mem/current();
          if mode is .Current { crash("currentAllocMode.kind is Current; this will never resolve") };
          mode
        },
        _ -> self,
      }
    }

    fn alloc(self: AllocMode, size: size, align: size): ptr {
      switch self.resolve() {
        .Current -> { crash("unreachable") },
        .SystemHeap -> mem/allocZeroed(size, align),
        .CustomHeap(alloc) -> {
          let zalloc = alloc.*.zalloc;
          zalloc(size, align)
        },
        .CustomArena(bump) -> {
          bump.pushLayout(size, align)
        },
        .Arena -> {
          mem/arena().pushLayout(size, align)
        },
        .Gc -> {
          crash("Gc is unimplemented; plan to support w/ bdwgc")
        }
      }
    }

    fn realloc(self: AllocMode, oldPtr: ptr, oldSize: size, align: size, newSize: size): ptr {
      switch self.resolve() {
        .Current -> { crash("unreachable") },
        .SystemHeap -> mem/realloc(oldPtr, oldSize, align, newSize),
        .CustomHeap(alloc) -> {
          let reallocFn = alloc.*.realloc;
          reallocFn(oldPtr, oldSize, align, newSize)
        },
        .CustomArena(bump) -> crash("UnsupportedOperation: Bump realloc"),
        .Arena -> crash("UnsupportedOperation:.Arena realloc"),
        .Gc -> crash("UnsupportedOperation: Gc realloc")
      }
    }

    fn free(self: AllocMode, ptr: ptr, size: size, align: size) {
      switch self.resolve() {
        .Current -> { crash("unreachable") },
        .SystemHeap -> mem/free(ptr, size, align),
        .CustomHeap(alloc) -> {
          let freeFn = alloc.*.free;
          freeFn(ptr, size, align)
        },
        .CustomArena(bump) -> crash("UnsupportedOperation: free"),
        .Arena -> crash("UnsupportedOperation: free"),
        .Gc -> crash("UnsupportedOperation: free")
      }
    }


    fn allocT[T](self: AllocMode): *mut T {
      self.alloc(size = types/sizeOf[T](), align = types/alignOf[T]()).as()
    }

    fn new[T](self: AllocMode, t: T): *mut T {
      let ref = self.allocT[T]();
      ref <- t;
      ref
    }

  }

  fn new[T](t: T): *mut T { AllocMode.Current.new(t) }

  let* tls arena: *mut Arena = zeroed();

  deftype alias ALLOC_STACK_MAX = 128
  let* tls allocStack: *mut FixList[AllocMode, ALLOC_STACK_MAX] = { 
    let* s = zeroed[FixList[AllocMode, ALLOC_STACK_MAX]]();
    s.push(.Arena);
    s
  };

  fn pushMode(mode: AllocMode) {
    allocStack.push(mode)
  }
  fn popMode(): AllocMode {
    allocStack.pop().!
  }
  fn current(): AllocMode {
    let s = allocStack.last().!;
    s
  }

  fn initTempArena() {
    if not arena.basePtr.isNull() crash("Arena already initialized");
    arena <- Arena/default();
  }

  fn arena(): *mut Arena {
    if arena.basePtr.isNull() { initTempArena() };
    arena
  }

}
