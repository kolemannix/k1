// Copyright (c) 2025 knix
// All rights reserved.

ns mem {

  // For now here's all I can do until I have dyn traits
  deftype Allocator = {
    malloc:  *(\(uword, uword) -> ptr),
    zalloc:  *(\(uword, uword) -> ptr),
    realloc: *(\(ptr, uword, uword, uword) -> ptr),
    free:    *(\(ptr, uword, uword) -> unit),
  }

  fn virtualAlloc(size: uword): ptr {
    // Workaround for not having implemented virtual alloc in the VM yet.
    if k1/IS_STATIC { alloc(size, 8) } else {
      let rw = posix/PROT_READ.bitOr(posix/PROT_WRITE);
      let privateAnon = posix/MAP_PRIVATE.bitOr(posix/MAP_ANON);
      let addr = posix/mmap(
        addr = ptr/NULL,
        len = size,
        prot = rw,
        flags = privateAnon,
        fd = -1,
        offset = 0
      );
      if addr == (posix/MAP_FAILED as ptr) crash("mmap failed");
      addr
    }
  }

  fn virtualRelease(base: ptr, len: uword): unit {
    if k1/IS_STATIC { free(base, len, 8) } else {
      let result = posix/munmap(base, len);
      if result == -1 crash("munmap of ptr {base} x {len} failed");
      ()
    }
  }

  deftype AllocMode = either
    Current,
    SystemHeap,
    CustomHeap(*mut Allocator),
    Arena,
    CustomArena(*mut Arena),
    Gc

  impl Print for AllocMode {
    fn printTo[W: Writer](self: Self, w: W): unit {
      w.writeString(self.kindName())
    }
  }

  ns AllocMode {

    fn supportsRealloc(self: AllocMode): bool { switch self {
      .Current -> crash("unreachable"),
      .SystemHeap or .CustomHeap(_) -> true,
      .Arena or .CustomArena(_) -> false,
      .Gc -> false
    } }

    fn requiresFree(self: AllocMode): bool { switch self {
      .Current -> crash("unreachable"),
      .SystemHeap -> true,
      .CustomHeap(_) -> true,
      .Arena -> false,
      .CustomArena(_) -> false,
      .Gc -> false
    } }

    fn kindName(self: AllocMode): string { switch self {
      .Current -> "current",
      .SystemHeap -> "system",
      .CustomHeap(_) -> "custom",
      .Arena -> "arena",
      .CustomArena(_) -> "custom_bump",
      .Gc -> "gc"
    } }

    fn resolve(self: AllocMode): AllocMode {
      switch self {
        .Current -> {
          let mode = mem/current();
          if mode is .Current { crash("currentAllocMode.kind is Current; this will never resolve") };
          mode
        },
        _ -> self,
      }
    }

    fn alloc(self: AllocMode, size: uword, align: uword): ptr {
      switch self.resolve() {
        .Current -> { crash("unreachable") },
        .SystemHeap -> mem/allocZeroed(size, align),
        .CustomHeap(alloc) -> {
          let zalloc = alloc.*.zalloc;
          zalloc(size, align)
        },
        .CustomArena(bump) -> {
          bump.pushLayout(size, align)
        },
        .Arena -> {
          mem/arena().pushLayout(size, align)
        },
        .Gc -> {
          crash("Gc is unimplemented; plan to support w/ bdwgc")
        }
      }
    }

    fn realloc(self: AllocMode, oldPtr: ptr, oldSize: uword, align: uword, newSize: uword): ptr {
      switch self.resolve() {
        .Current -> { crash("unreachable") },
        .SystemHeap -> mem/realloc(oldPtr, oldSize, align, newSize),
        .CustomHeap(alloc) -> {
          let reallocFn = alloc.*.realloc;
          reallocFn(oldPtr, oldSize, align, newSize)
        },
        .CustomArena(bump) -> crash("UnsupportedOperation: Bump realloc"),
        .Arena -> crash("UnsupportedOperation:.Arena realloc"),
        .Gc -> crash("UnsupportedOperation: Gc realloc")
      }
    }

    fn free(self: AllocMode, ptr: ptr, size: uword, align: uword): unit {
      switch self.resolve() {
        .Current -> { crash("unreachable") },
        .SystemHeap -> mem/free(ptr, size, align),
        .CustomHeap(alloc) -> {
          let freeFn = alloc.*.free;
          freeFn(ptr, size, align)
        },
        .CustomArena(bump) -> crash("UnsupportedOperation: free"),
        .Arena -> crash("UnsupportedOperation: free"),
        .Gc -> crash("UnsupportedOperation: free")
      }
    }


    fn allocT[T](self: AllocMode): *mut T {
      self.alloc(size = types/sizeOf[T](), align = types/alignOf[T]()) as *mut T
    }

    fn new[T](self: AllocMode, t: T): *mut T {
      let ref = self.allocT[T]();
      ref <- t;
      ref
    }

  }

  fn new[T](t: T): *mut T { AllocMode.Current.new(t) }

  let* tls arena: *mut Arena = zeroed();

  deftype alias ALLOC_STACK_MAX = 128uword
  let* tls allocStack: *mut FixList[AllocMode, ALLOC_STACK_MAX] = { 
    let* s = zeroed[FixList[AllocMode, ALLOC_STACK_MAX]]();
    s.push(.Arena);
    s
  };

  // Eventually, we want 'push'/'pop' for allocMode
  fn pushMode(mode: AllocMode): unit {
    allocStack.push(mode)
  }
  fn popMode(): AllocMode {
    allocStack.pop().!
  }
  fn current(): AllocMode {
    let s = allocStack.last().!;
    s
  }

  fn initTempArena(): unit {
    if not arena.basePtr.isNull() crash("Arena already initialized");
    arena <- Arena/default();
  }

  fn arena(): *mut Arena {
    if arena.basePtr.isNull() { initTempArena() };
    arena
  }

}
