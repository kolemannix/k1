// Copyright (c) 2025 knix
// All rights reserved.

ns Opt {
  fn isSome[T](self: ?T): bool { self is .Some(_) }
  fn isNone[T](self: ?T): bool { self is .None }

  fn get[T](context locn: compiler/SourceLocation)(self: ?T): T {
    if self is .Some(t) t else {
      crash("Opt.get on None")
    }
  }

  fn contains[T: Equals](self: ?T, t: T): bool {
    switch self {
      .None -> false,
      .Some(v) -> v == t
    }
  }

  // I'm leaving this separate function here 
  // because at one point it exercised a really weird compiler bug
  fn opt_equals[T](a: Opt[T], b: Opt[T]): bool where T: Equals {
    if a is .Some(at) {
      if b is .Some(bt) at == bt else false
    } else {
      b is .None
    }
  }

  fn map[T, U](self: Opt[T], f: some \T -> U): Opt[U] {
    switch self {
      .None -> .None,
      .Some(t) -> .Some(f(t))
    }
  }

}

// Convenience constructors in the global scope for Opt instances
fn none[T](): Opt[T] { Opt.None[T] }
fn some[T](value: T): Opt[T] { Opt.Some[T](value) }


impl[T: Equals] Equals for Opt[T] {
  fn equals(self: Opt[T], other: Opt[T]): bool {
    // I'm leaving this separate function call here 
    // because at one point it exercised a really weird compiler bug
    Opt/opt_equals(self, other)
  }
}

impl[A] Try[T = A, E = unit] for Opt[A] {
  fn error(_e: unit): Opt[T] { .None }
  fn value(t: T): Opt[T] { Opt.Some(t) }

  fn isOk(self: Opt[T]): bool { self is .Some(_) }
  fn getError(self: Opt[T]): unit {
    switch self {
      .None -> (),
      .Some(_) -> crash("getError on Opt.Some")
    }
  }
  fn getValue(self: Opt[T]): T { self.get() }
}

impl[T: Print] Print for Opt[T] {
  fn printTo[W: Writer](self: Opt[T], w: W): unit {
    if self is .Some(v) w.writeString("Some({v})") else w.writeString("None")
  }
}
