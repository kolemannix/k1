// Represents a 'pushable' contiguous collection of Ts, with a fixed capacity,
// and inline storage. 
//  
// For example, A FixList[byte, 10] is 14 bytes long, and looks like:
// +----+----------+
// |used|10 items  |
// +----+----------+
// 0    4
deftype FixList[T, N: static size] = { used: u32, data: Array[T, N] }
ns FixList {
  fn cap[T, N: static size](self: FixList[T, N]): size { self.data.len() }
  fn len[T, N: static size](self: FixList[T, N]): size { self.used as size }

  fn clear[T, N: static size](self: *mut FixList[T, N]): unit {
    #if k1/DEBUG self.data*.memset(0xCD);
    self.used* <- 0
  }

  fn push[T, N: static size](self: *mut FixList[T, N], value: T): unit {
    let used: size = self.len();
    if used < self.cap() {
      self.data*.set(used, value);
      self.used* <- used as u32 + 1;
    } else {
      let typename = types/getTypeName[typeOf(self).value]();
      crash("{typename} cannot fulfill push. {used + 1} > {self.cap()}")
    }
  }

  fn tryPush[T, N: static size](self: *mut FixList[T, N], value: T): Result[unit, unit] {
    let used: size = self.len();
    if used < self.cap() {
      self.data*.set(used, value);
      self.used* <- used as u32 + 1;
      .Ok(())
    } else {
      .Err(())
    }
  }

  fn tryPushN[T, N: static size](self: *mut FixList[T, N], values: View[T]): Result[unit, unit] {
    let needed = self.len() + values.len();
    if needed <= self.cap() {
      let dstSlice = self.data*.asBuffer().slice(start = self.len(), end = needed);
      Buffer/copyFrom(src = values.innerBuffer(), dst = dstSlice);
      self.used* <- needed as u32;
      .Ok(())
    } else {
      .Err(())
      //.Err("{typename} cannot fulfill pushN. {needed} (needed) > {self.capacity()}")
    }
  }

  fn pushN[T, N: static size](self: *mut FixList[T, N], values: View[T]): unit {
    let result = self.tryPushN[T, N](values);
    if result is .Err(msg) crash("FixList out of space")
  }

  fn asBuffer[T, N: static size](self: *mut FixList[T, N]): Buffer[T] {
    self.data*.asBuffer().slice(0, self.len())
  }

  fn asView[T, N: static size](self: *FixList[T, N]): View[T] {
    self.data*.asView().slice(0, self.len())
  }

  fn get[T, N: static size](self: *FixList[T, N], index: size): T {
    self.toMut.getRef(index).*
  }

  fn getRef[T, N: static size](self: *mut FixList[T, N], index: size): *mut T {
    if index < self.len() {
      self.data*.getRef(index)
    } else {
      crash("FixList index out of bounds: {index} > {self.len()}")
    }
  }

  fn set[T, N: static size](self: *mut FixList[T, N], index: size, value: T): unit {
    self.getRef(index) <- value
  }

  fn last[T, N: static size](self: *FixList[T, N]): ?T {
    self.asView().last()
  }

  fn pop[T, N: static size](self: *mut FixList[T, N]): ?T {
    switch self.last() {
       .Some(t) -> {
         self.used* <- self.used - 1;
         .Some(t)
       },
       .None -> .None
    }
  }

}
