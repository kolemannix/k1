// Copyright (c) 2025 knix
// All rights reserved.

// TODO: CString type
deftype alias CString = ptr
ns CString { 
}

ns string {
  
  fn view(self: string): View[char] { self.view }

  fn get(self: string, index: size): char {
    self.view.get(index)
  }

  fn viewBytes(self: string): View[byte] {
    self.view().asByteView()
  }

  fn cloned(self: string): string {
    fromView(self.view.cloned())
  }

  fn fromView(view: View[char]): string {
    { view }
  }

  fn fromBytes(view: View[byte]): string {
    { view: view.toCharView() }
  }

  fn wrapList(list: List[char]): string {
    { view: list.asView() }
  }

  fn wrapBuffer(buffer: Buffer[char]): string {
    { view: View/wrapBuffer(buffer) }
  }

  fn wrapByteBuffer(buffer: Buffer[byte]): string {
    { view: View/wrapBuffer(buffer.toCharBuffer()) }
  }

  fn copyFromBytes(buffer: Buffer[byte]): string {
    let copied: Buffer[byte] = buffer.cloned();
    wrapByteBuffer(copied)
  }

  fn copyFromBuffer(buffer: Buffer[char]): string {
    let copied = buffer.cloned();
    wrapBuffer(copied)
  }

  fn len(self: string): size { self.view.len() }

  fn isEmpty(self: string): bool { self.len() == 0 }
  fn nonEmpty(self: string): bool { self.len() != 0 }

  fn first(self: string): ?char {
    if self.nonEmpty() .Some(self.get(0)) else .None
  }

  fn last(self: string): ?char {
    if self.nonEmpty() .Some(self.get(self.len() - 1)) else .None
  }


  fn indexOf(self: string, c: char): i64 {
    for self.view {
      if it == c return(itIndex)
    };
    -1
  }

  fn concat(self: string, other: string): string {
    fromView(self.view.concat(other.view))
  }

  fn appendCharIn(context alloc: mem/AllocMode)(self: string, c: char): string {
    let newLength = self.len() + 1;
    let newBuffer = self.view.innerBuffer()._enlargedCloneIn(newLength);
    newBuffer.set(self.len(), c);
    wrapBuffer(newBuffer)
  }

  fn appendChar(self: string, c: char): string {
    appendCharIn(context .Current)(self, c)
  }

  fn splitByChar(self: string, delim: char): List[string] {
    let* ranges = List/empty[{ start: size, len: size }]();
    let* r = { start: 0: size, len: 0: size };

    for c in self {
      //println("{itIndex} {c} ({r.start},{r.len})");
      if c == delim {
        ranges.push(r);
        r <- { start: itIndex + 1, len: 0 };
      } else {
        r.len* <- r.len + 1
      };
    };

    if r.len != 0 {
      ranges.push(r);
    };

    ranges.map(\range. {
      let end = range.start + range.len;
      self.substring(range.start, end)
    })
  }

  fn indexOfString(self: string, target: string): ?size {
    for self.view {
      let i = itIndex;
      if i + target.len() >= self.len() {
        return(.None)
      };
      let sub = self.substring(i, i + target.len());
      if sub == target { return(.Some(i)) };
    };
    .None
  }

  fn substring(self: string, start: size, end: size): string {
    { view: self.view.slice(start, end) }
  }
  fn slice(self: string, start: size, end: size): string {
    { view: self.view.slice(start, end) }
  }

  fn take(self: string, count: size): string { self.substring(0,     count) }
  fn drop(self: string, count: size): string { self.substring(count, self.len()) }

  fn chunks(self: string, size: size): View[string] {
    let charViews: View[View[char]] = self.view.chunks(size);
    mem/bitcast[View[View[char]], View[string]](charViews)
  }

  fn startsWith(self: string, other: string): bool {
    self.substring(0, other.len()) == other
  }

  fn dataPtr(self: string): ptr {
    self.view.dataPtr()
  }

  fn toCString(context alloc: mem/AllocMode)(self: string): { ptr: ptr, len: size } {
    if self.isEmpty()                  { ptr: "\0".dataPtr(), len: 0 }
    else if self.last() is .Some('\0') { ptr: self.dataPtr(), len: self.len() - 1 }
    else                               { ptr: self.appendCharIn('\0').dataPtr(), len: self.len() }
  }

  fn wrapCString(cString: ptr): string {
    let i = 0;
    loop {
      let c = cString.refAtIndex[char](i);
      if c.* == '\0' {
        break();
      } else {
        i := i + 1;
      }
    };
    let buffer = Buffer/fromPtrAndCount[char](
      count = i,
      pointer = cString
    );
    wrapBuffer(buffer)
  }

  fn fromCString(cString: ptr): string {
    let* chars = List/empty[char]();
    let i = 0;
    loop {
      let c = cString.refAtIndex[char](i);
      if c.* == '\0' {
        break();
      } else {
        chars.push(c);
        i := i + 1;
      }
    };
    wrapList(chars)
  }

  fn toInt(self: string): ?int {
    if self.isEmpty() { return(.None) };

    let neg = self.get(0) == '-';
    let i = if neg 1 else 0;
    let total = 0;
    while i < self.len() {
      let c = self.get(i);
      let digit = c.toDigitValue();
      if digit is .Some(digit) {
        total := (total * 10) + digit as int;
      } else {
        return(.None);
      };
      i := i + 1;
    };

    some(
      if neg { total * -1 } else { (total) }
    )
  }

  fn capitalizeAscii(self: string): string {
    if self.first() is .Some(c) and c.isAsciiLower() {
      let cloneChars: Buffer[char] = self.view.buffer.cloned();
      cloneChars.set(0, c.toAsciiUpper());
      wrapBuffer(cloneChars)
    } else self
  }
 
  fn parseBase10(s: string): ?uint {
    let o: uint = 0;
    for c in s {
      if not c.isAsciiDigit() { return(.None) };
      let digitValue: uint = (c as u8 - 48) as uint;
      o := o * 10;
      o := o + digitValue;
    };
    .Some(o)
  }

}

impl Show for string {
  fn show(self: string): string { self }
}

impl Iterable[Item = char, I = BufferIterator[char]] for string {
  fn iterator(self: string): I { self.view().iterator() }
}

impl Iterable[Item = char, I = BufferIterator[char]] for *string {
  fn iterator(self: *string): I { self.*.iterator() }
}
