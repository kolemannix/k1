// Copyright (c) 2025 knix
// All rights reserved.

// TODO: CString type
deftype alias CString = Pointer
ns CString { 
}

ns string {
  
  fn view(self: string): View[char] { self.view }

  fn get(self: string, index: uword): char {
    self.view.get(index)
  }

  fn viewBytes(self: string): View[byte] {
    self.view().toByteView()
  }

  fn clone(self: string): string {
    fromView(self.view.cloned())
  }

  fn fromView(view: View[char]): string {
    { view }
  }

  fn fromBytes(view: View[byte]): string {
    { view: view.toCharView() }
  }

  fn wrapList(list: List[char]): string {
    { view: list.asView() }
  }

  fn wrapBuffer(buffer: Buffer[char]): string {
    { view: View/wrapBuffer(buffer) }
  }

  fn wrapByteBuffer(buffer: Buffer[byte]): string {
    { view: View/wrapBuffer(buffer.toCharBuffer()) }
  }

  fn copyFromBytes(buffer: Buffer[byte]): string {
    let copied: Buffer[byte] = buffer.cloned();
    wrapByteBuffer(copied)
  }

  fn copyFromBuffer(buffer: Buffer[char]): string {
    let copied = buffer.cloned();
    wrapBuffer(copied)
  }

  fn len(self: string): uword { self.view.len() }

  fn isEmpty(self: string): bool { self.len() == 0 }
  fn nonEmpty(self: string): bool { self.len() != 0 }

  fn first(self: string): ?char {
    if self.nonEmpty() .Some(self.get(0)) else .None
  }

  fn last(self: string): ?char {
    if self.nonEmpty() .Some(self.get(self.len() - 1)) else .None
  }


  fn indexOf(self: string, c: char): i64 {
    for self.view do {
      if it == c return(itIndex as i64)
    };
    -1
  }

  fn concat(self: string, other: string): string {
    fromView(self.view.concat(other.view))
  }

  fn appendChar(self: string, c: char): string {
    let newLength = self.len() + 1;
    let newBuffer = self.view.innerBuffer()._enlargedClone(newLength);
    newBuffer.set(self.len(), c);
    wrapBuffer(newBuffer)
  }

  fn splitByChar(self: string, delim: char): List[string] {
    let* ranges = List/empty[{ start: uword, len: uword }]();
    let* r = { start: 0: uword, len: 0: uword };

    for c in self do {
      if c == delim {
        if r.len != 0 {
          ranges.push(r);
          r <- { start: itIndex + 1, len: 0 };
        }
      } else {
        r.len* <- r.len + 1
      };
    };

    if r.len != 0 {
      ranges.push(r);
    };

    for range in ranges yield {
      let end = range.start + range.len;
      self.substring(range.start, end)
    }
  }

  fn indexOfString(self: string, target: string): ?uword {
    for self.view do {
      let i = itIndex;
      if i + target.len() >= self.len() {
        return(.None)
      };
      let sub = self.substring(i, i + target.len());
      if sub == target { return(.Some(i)) };
    };
    .None
  }

  fn substring(self: string, start: uword, end: uword): string {
    { view: self.view.slice(start, end) }
  }

  fn take(self: string, count: uword): string { self.substring(0,     count) }
  fn drop(self: string, count: uword): string { self.substring(count, self.len()) }

  fn startsWith(self: string, other: string): bool {
    self.substring(0, other.len()) == other
  }

  fn dataPointer(self: string): Pointer {
    self.view.dataPointer()
  }

  fn toCString(context alloc: mem/AllocMode)(self: string): { ptr: Pointer, len: uword } {
    if self.isEmpty()                  { ptr: "\0".dataPointer(), len: 0 }
    else if self.last() is .Some('\0') { ptr: self.dataPointer(), len: self.len() - 1 }
    else                               { ptr: self.appendChar('\0').dataPointer(), len: self.len() }
  }

  fn wrapCString(cString: Pointer): string {
    let i = 0: uword;
    loop {
      let c = cString.refAtIndex[char](i);
      if c.* == '\0' {
        break();
      } else {
        i := i + 1;
      }
    };
    let buffer = Buffer/fromRawPointerAndCount[char](
      count = i,
      pointer = cString
    );
    wrapBuffer(buffer)
  }

  fn fromCString(cString: Pointer): string {
    let* chars = List/empty[char]();
    let i = 0: uword;
    loop {
      let c = cString.refAtIndex[char](i);
      if c.* == '\0' {
        break();
      } else {
        chars.push(c);
        i := i + 1;
      }
    };
    wrapList(chars)
  }

  fn toInt(self: string): ?int {
    if self.isEmpty() { return(.None) };

    let neg = self.get(0) == '-';
    let i = if neg 1uword else 0uword;
    let total = 0uword;
    while i < self.len() {
      let c = self.get(i);
      let digit = c.toDigitValue();
      if digit is .Some(digit) {
        total := (total * 10) + digit as uword;
      } else {
        return(.None);
      };
      i := i + 1;
    };

    some(
      if neg { (total as int) * -1 } else { total as int }
    )
  }

}

impl Show for string {
  fn show(self: string): string { self }
}

impl Iterable[Item = char, I = BufferIterator[char]] for string {
  fn iterator(self: string): I { self.view().iterator() }
}

impl Iterable[Item = char, I = BufferIterator[char]] for *string {
  fn iterator(self: *string): I { self.*.iterator() }
}
