// Copyright (c) 2025 knix
// All rights reserved.

// A growable, ordered collection of elements.
// Backed by an efficient, contiguously allocated buffer
//
// List stores a copy of its allocator, because it is intended
// to be a convenient and easy workhorse for most use cases
ns List {

  ///////////////////////////
  // Construction functions

  use mem/AllocMode

  fn empty[T](): List[T] {
    withCapacity[T](0)
  }

  fn len[T](self: List[T]): size { self.len }
  fn cap[T](self: List[T]): size { self.buffer.len }

  fn filled[T](size: size, value: T): List[T] {
    let buffer = Buffer/filled(size, value);
    { len: size, buffer: buffer }
  }

  fn filledIn[T](context mode: AllocMode)(size: size, value: T): List[T] {
    let buffer = Buffer/filledIn(size, value);
    { len: size, buffer: buffer }
  }

  fn withCapacity[T](cap: size): List[T] {
    let buffer = Buffer/_allocate[T](cap);
    { len: 0, buffer: buffer }
  }

  fn withCapacityIn[T](context mode: AllocMode)(cap: size): List[T] {
    let buffer = Buffer/_allocateIn[T](cap);
    { len: 0, buffer: buffer }
  }

  fn reserve[T](self: *mut List[T], alloc: AllocMode, count: size): unit {
    if self.cap() >= count { return(()) };
    self.buffer*._growTo[T](context alloc)(count);
    assertdbg(self.buffer.len == count);
  }

  fn single[T](value: T): List[T] {
    filled[T](1, value)
  }

  fn wrapBuffer[T](buffer: Buffer[T]): List[T] {
    { len: buffer.len, buffer: buffer }
  }

  // Return only the part of our buffer with Ts in it!!!
  // Does not create a copy!
  fn asBuffer[T](self: List[T]): Buffer[T] {
    self.buffer.slice(0, self.len)
  }

  fn asView[T](self: List[T]): View[T] {
    View/wrapBuffer(self.asBuffer[T]())
  }

  fn copyToBuffer[T](self: List[T]): Buffer[T] {
    self.asBuffer().cloned()
  }

  fn copyToArray[T, N: static size](self: List[T], count: N): *mut Array[T, N] {
    let countVal = count.fromStatic();
    assertEquals(self.len, countVal);
    let base: ptr = self.asBuffer().cloned().dataPtr();
    base as *mut Array[T, N]
  }

  // The possibly-uninitialized backing buffer of this List
  fn innerBuffer[T](self: List[T]): Buffer[T] { self.buffer }

  fn getRef[T](self: *mut List[T], index: size): *mut T {
    if index < 0 or index >= self.len {
      crash("List index out of bounds: {index} >= {self.len}")
    };
    self.buffer.getRefUnchecked[T](index)
  }

  fn set[T](self: *mut List[T], index: size, elem: T): unit {
    if index >= self.len {
      crash("List index out of bounds: {index} >= {self.len}")
    };
    self.buffer.set(index, elem);
  }

  fn get[T](self: List[T], index: size): T {
    if index >= self.len {
      crash("List index out of bounds: {index} >= {self.len}")
    };
    self.buffer.get(index)
  }

  fn getOpt[T](self: List[T], index: size): ?T {
    if index >= self.len {
      .None
    } else .Some(self.buffer.get(index))
  }

  fn _grow[T](context mode: AllocMode)(self: *mut List[T]): unit {
    let newCap: size = if self.buffer.isEmpty() {
      // For large elements, just allocate what's needed - Rust's RawVec does this :)
      let elemSize = core/types/sizeOf[T]();
      if elemSize >= 1024 1 else 8
    } else {
      self.cap() * 2
    };
    self.reserve(mode, newCap);
    ()
  }

  fn cloned[T](self: List[T]): List[T] {
    let newBuffer = self.buffer.cloned();
    { len: self.len, buffer: newBuffer }
  }

  fn pushIn[T](context mode: AllocMode)(self: *mut List[T], elem: T): unit {
    let startLength = self.len;
    if startLength == self.*.cap() {
      self._grow();
    };
    self.len* <- startLength + 1;
    self.set(startLength, elem);
    ()
  }

  fn push[T](self: *mut List[T], elem: T): unit {
    self.pushIn[T](context .Current)(elem)
  }

  fn slice[T](self: List[T], start: size, end: size): Buffer[T] {
    if self.len == 0 return(Buffer/empty[T]());
    if end > self.len { crash("List slice end out of bounds: {end}") };
    self.buffer.slice(start, end)
  }

  fn isEmpty[T](self: List[T]): bool {
    self.len == 0
  }

  fn nonEmpty[T](self: List[T]): bool {
    self.len > 0
  }

  fn firstRef[T](self: *mut List[T]): ?(*mut T) {
    if self.nonEmpty() {
      .Some(self.getRef(0))
    } else {
      .None
    }
  }

  fn first[T](self: List[T]): ?T {
    if self.nonEmpty() .Some(self.get(0)) 
    else .None
  }

  fn lastRef[T](self: *mut List[T]): ?(*mut T) {
    if self.nonEmpty() .Some(self.getRef(self.len - 1))
    else .None
  }

  fn last[T](self: List[T]): ?T {
    if self.nonEmpty() .Some(self.get(self.len - 1))
    else .None
  }

  fn clear[T](self: *mut List[T]): unit {
    self.len* <- 0
  }

  fn reverse[T](self: *mut List[T]): unit {
    let i = 0;
    while (i < (self.len / 2)) {
      let j = self.len - i - 1;
      self.swap(i, j);
      i := i + 1;
    }
  }

  fn reversed[T](self: List[T]): List[T] {
    let* clone = self.cloned();
    clone.reverse[T]();
    clone.*
  }

  fn appendList[T](self: *mut List[T], other: List[T]): unit {
    self.appendBuffer(other.asBuffer())
  }

  fn appendBuffer[T](self: *mut List[T], other: Buffer[T]): unit {
    self.reserve(.Current, self.len + other.len);
    let dst = self.innerBuffer().slice(start = self.len, end = self.len + other.len);
    Buffer/copyFrom(src = other, dst = dst);
    self.len* <- self.len + other.len;
  }

  fn appendView[T](self: *mut List[T], other: View[T]): unit {
    self.appendBuffer(other.innerBuffer())
  }

  fn swap[T](self: *mut List[T], indexA: size, indexB: size): unit {
    if indexA == indexB { return() };
    if indexA >= self.len {
      crash("List index out of bounds: {indexA} >= {self.len}")
    };
    if indexA >= self.len {
      crash("List index out of bounds: {indexB} >= {self.len}")
    };
    self.buffer*.swap[T](indexA, indexB);
  }

  fn sort[T](input: *mut List[T]): unit where T: Comparable {
  
    if input.len <= 1 return(());
  
    let halfIndex = input.len / 2;
    let pivot = input.get(halfIndex);
  
    let* left = List/withCapacity[T](halfIndex);
    let* right = List/withCapacity[T](halfIndex);
    let* equal = List/withCapacity[T](4);
  
    for item in input.* {
      switch item.compare(pivot) {
        .Less -> left.push(item),
        .Equal -> equal.push(item),
        .Greater -> right.push(item)
      }
    };
  
    left.sort();
    right.sort();
  
    let i = 0;
    for item in left.* {
      input.set(i, item);
      i := i + 1;
    };
  
    for item in equal.* {
      input.set(i, item);
      i := i + 1;
    };
  
    for item in right.* {
      input.set(i, item);
      i := i + 1;
    };
  }

  fn sorted[T](self: List[T]): List[T] where T: Comparable {
    let* copy = self.cloned();
    copy.sort();
    copy.*
  }

  // TODO(stdlib) remove or tweak this; assumes global allocation
  fn join[T: Show](self: List[T], sep: string): string {
    let* b = StringBuilder/new();
    for s in self {
      b.writeString(s.show());
      let isLast = itIndex != self.len - 1;
      if not isLast {
        b.writeString(sep);
      }
    };
    b.build()
  }

  fn fromMap[T, Iter, Iterable, U](input: Iterable, f: some \T -> U): List[U]
  where Iter: Iterator[Item = T], Iterable: Iterable[Item = T, I = Iter]
  {
    let* iter = input.iterator();
    let* us = List/withCapacity[U](iter.sizeHint().atLeast);
    for iter.* {
      let u = f(it);
      us.push(u)
    };
    us.*
  }

  fn map[T, U](self: List[T], f: some \T -> U): List[U] {
    let* us = List/withCapacity[U](self.len);
    for i in self { us.push[U](f(i)) };
    us.*
  }
  
  fn flatMap[T, U](self: List[T], f: some \T -> List[U]): List[U] {
    let* us = List/empty[U]();
    for i in self { us.appendList[U](f(i)) };
    us.*
  }
  
  fn filter[T](self: List[T], f: some \T -> bool): List[T] {
    let* keep = List/empty[T]();
    for i in self { if f(i) keep.push(i) };
    keep
  }

}

impl Writer for *mut List[char] {
  fn writeByte(self: Self, value: u8): unit { self.push(value as char) }
  fn writeBytes(self: Self, bytes: View[byte]): unit { self.appendView(bytes.toCharView()) }
}

impl Writer for *mut List[u8] {
  fn writeByte(self: Self, value: u8): unit { self.push(value) }
  fn writeBytes(self: Self, bytes: View[byte]): unit {
    self.appendView(bytes)
  }
}

impl Equals for List[u8] {
  fn equals(self: List[u8], other: List[u8]): bool { self.asBuffer() == other.asBuffer() }
}

impl Equals for List[int] {
  fn equals(self: List[int], other: List[int]): bool { self.asBuffer() == other.asBuffer() }
}

impl[T: Equals] Equals for List[T] {
  fn equals(self: List[T], other: List[T]): bool {
    if self.len != other.len false else {
      for a in self {
        let b = other.get(itIndex);
        if a != b return(false);
      };
      true
    }
  }
}

impl[T: Print] Print for List[T] {
  fn printTo[W: Writer](self: List[T], w: W): unit {
    w.writeChar('[');
    for self {
      it.printTo(w);
      let last = itIndex == self.len - 1;
      if not last {
        w.writeString(",");
      };
    };
    w.writeChar(']');
  }
}

impl[T] Iterable[Item = T, I = BufferIterator[T]] for List[T] {
  fn iterator(self: Self): I {
    self.asBuffer().iterator()
  }
}

impl[T] Iterable[Item = T, I = BufferIterator[T]] for *List[T] {
  fn iterator(self: Self): I {
    self.*.iterator()
  }
}
