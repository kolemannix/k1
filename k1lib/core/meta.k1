// Copyright (c) 2025 knix
// All rights reserved.

ns meta {

  ability CodeWriter {
    fn line(self: Self, line: string): unit 
    fn lines[Iter: Iterator[Item = string]](self: Self, lines: Iter): unit {
      for l in lines do { self.line(l) }
    }
    fn var[T](self: Self, name: string, value: T): unit 
  }
  
  impl[W: Writer] CodeWriter for W {
    fn line(self: Self, line: string): unit {
      self.writeString(line);
      self.writeString("\n");
    }
    
    fn var[T](self: Self, name: string, value: T): unit {
      let bakedVar = meta/bakedVariable[T](name, value);
      self.writeString(bakedVar)
    }
  }

  fn bakedValueExpr[T](value: T): string {
    let valueId = bakeStaticValue[T](value);
    `core/meta/getStaticValue({valueId})`
  }

  fn bakedVariable[T](name: string, value: T): string {
    let bakedValueExpr: string = bakedValueExpr[T](value);
    let typeId = types/typeId[T]();
    `let {name}: typeFromId({typeId}) = {bakedValueExpr};\n`
  }

  // Note: If we had an interface for "growable collection", we could implement it here.
  //       len, get, empty, (push)
  fn defineSoA[T](name: string): string {
    let structTypeId = types/typeId[T]();
    let tt = "typeFromId({structTypeId})";
    let schema = types/typeSchema(structTypeId);
    require types/typeSchema(structTypeId) is .Struct({ fields }) else
      crash("Its called a STRUCT of arrays for a reason");
    if fields.isEmpty() { crash("Input struct must have at least one field") };

    let* code = StringBuilder/new();
    code.line("deftype {name} = {{");
    for f in fields do {
      code.line("  ARR_{f.name}: List[typeFromId({f.typeId})],");
    };
    code.line("}");

    // begin ns
    code.line(`ns {name} {{`);

    // begin fn get
    code.line(`  fn get(self: {name}, index: size): {tt} {{`);
    code.line(`    let* ret: *mut {tt} = mem/zeroed();`);
    for f in fields do {
      code.line(`    ret.{f.name}* <- self.ARR_{f.name}.get(index);`)
    };
    code.line(`    ret.*`);
    code.line(`  }`); // end fn get

    // begin fn empty
    code.line(`  fn empty(): {name} {{ {{`);
    for f in fields do {
      code.line(`    ARR_{f.name}: List/empty(),`);
    };
    code.line(`  } }`); // end fn empty

    // begin fn push
    code.line(`  fn push(self: *mut {name}, value: {tt}): unit {{`);
    for f in fields do {
      code.line(`    self.ARR_{f.name}*.push(value.{f.name});`)
    };
    code.line(`}`); // end fn push

    code.line(`}`); // end ns
    code.build()
  }

}
