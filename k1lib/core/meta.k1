// Copyright (c) 2025 knix
// All rights reserved.

ns meta {

  fn bakedValueExpr[T](value: T): string {
    let valueId = bakeStaticValue[T](value);
    `core/meta/getStaticValue({valueId})`
  }

  fn bakedVariable[T](name: string, value: T): string {
    let bakedValueExpr: string = bakedValueExpr[T](value);
    let typeId = types/typeId[T]();
    `let {name}: typeFromId({typeId}) = {bakedValueExpr};\n`
  }

  deftype CodeBuilder = { sb: StringBuilder }
  ns CodeBuilder {
    fn new(): CodeBuilder { { sb: StringBuilder/withCapacity(1024) } }
    fn string(self: CodeBuilder, line: string): unit {
      self.sb.writeString(line);
    }
    fn line(self: CodeBuilder, line: string): unit {
      self.sb.writeString(line);
      self.sb.writeString("\n");
    }
    fn lines[Iter: Iterator[Item = string]](self: CodeBuilder, lines: Iter): unit {
      for l in lines do { self.line(l) }
    }
    
    fn var[T](self: CodeBuilder, name: string, value: T): unit {
      let bakedVar = bakedVariable[T](name, value);
      self.sb.writeString(bakedVar)
    }
    fn build(self: CodeBuilder): string { self.sb.build() }
  }

  // Note: If we had an interface for "growable collection", we could implement it here.
  //       len, get, empty, (push)
  fn defineSoA[T](name: string): string {
    let structTypeId = types/typeId[T]();
    let tt = "typeFromId({structTypeId})";
    let schema = types/typeSchema(structTypeId);
    require types/typeSchema(structTypeId) is .Struct({ fields }) else
      crash("Its called a STRUCT of arrays for a reason");
    if fields.isEmpty() { crash("Input struct must have at least one field") };

    let code = CodeBuilder/new();
    // nocommit tidy it back up
    println("{fields.len()}");
    println("{fields.get(0).name} {fields.get(0).typeId}");
    println("{fields.get(1).name}");
    println("{fields.get(2).name}");
    code.line("\n// {fields.get(0).name}");
    code.line("// {fields.get(1).name}");
    code.line("// {fields.get(2).name}");
    for f in fields do { code.line("// f{itIndex}: {f.name}") };
    code.line("deftype {name} = {{");
    for f in fields do {
      code.line("  ARR_{f.name}: List[typeFromId({f.typeId})],");
    };
    code.line("}");

    // begin ns
    code.line(`ns {name} {{`);

    // begin fn get
    code.line(`  fn get(self: {name}, index: uword): {tt} {{`);
    code.line(`    let* ret: *mut {tt} = mem/zeroed();`);
    for f in fields do {
      code.line(`    ret.{f.name}* <- self.ARR_{f.name}.get(index);`)
    };
    code.line(`    ret.*`);
    code.line(`  }`); // end fn get

    // begin fn empty
    code.line(`  fn empty(): {name} {{ {{`);
    for f in fields do {
      code.line(`    ARR_{f.name}: List/empty(),`);
    };
    code.line(`  } }`); // end fn empty

    // begin fn push
    code.line(`  fn push(self: *mut {name}, value: {tt}): unit {{`);
    for f in fields do {
      code.line(`    self.ARR_{f.name}*.push(value.{f.name});`)
    };
    code.line(`}`); // end fn push

    code.line(`}`); // end ns
    code.build()
  }

}
