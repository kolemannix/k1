// Copyright (c) 2025 knix
// All rights reserved.

fn assertEquals[T: Print and Equals](context locn: compiler/SourceLocation)(a: T, b: T): unit {
  if a != b {
    crash("ASSERT FAILED: {a} != {b}")
  }
}

ns iter {

  fn find[T, Iter: Iterator[Item = T], I: Iterable[Item = T, I = Iter]](iterable: I, pred: some \T -> bool): ?T {
    for iterable do {
      if pred(it) return(.Some(it))
    };
    .None
  }

  fn position[T: Equals, Iter: Iterator[Item = T], I: Iterable[Item = T, I = Iter]](iterable: I, needle: T): ?size {
    for iterable do {
      if it == needle return(.Some(itIndex))
    };
    .None
  }

  fn contains[T: Equals, Iter: Iterator[Item = T], I: Iterable[Item = T, I = Iter]](iterable: I, needle: T): bool {
    position(iterable, needle).isSome()
  }

  fn forall[T, Iter: Iterator[Item = T], I: Iterable[Item = T, I = Iter]](iterable: I, pred: some \T -> bool): bool {
    for iterable do { if not pred(it) return(false) };
    true
  }

  fn exists[T, Iter: Iterator[Item = T], I: Iterable[Item = T, I = Iter]](iterable: I, pred: some \T -> bool): bool {
    for iterable do {
      if pred(it) return(true)
    };
    false
  }

}

fn inc(i: *mut size): unit { i <- i.* + 1 }

fn identity[T](value: T): T { value }

fn printIt[T: Print](value: T): unit {
  value.printTo(io/STDOUT)
}

fn print(s: string): unit {
  // TODO: Instead of this hack, make write(Sink, View[byte]) the intrinsic.
  if k1/IS_STATIC {
    if s != "\n" {
      k1/emitCompilerMessage(compiler/location(), .Info, s)
    }
  } else {
    io/STDOUT.writeString(s)
  };
  ()
}
fn println(s: string): unit {
  // Whatever our implementation of print should be able to buffer
  // such that its better to call twice than allocate a garbage string
  print(s);
  print("\n");
}

fn eprint(s: string): unit {
  if k1/IS_STATIC {
    k1/emitCompilerMessage(compiler/location(), .Info, s)
  } else {
    io/STDERR.writeString(s)
  };
  ()
}
fn eprintln(s: string): unit {
  // Whatever our implementation of print should be able to buffer
  // such that its better to call twice than allocate a garbage string
  eprint(s);
  eprint("\n");
}

#if k1/OS_POSIX
ns io {
  deftype OutStream = { fileNo: i32 }
  let STDOUT: OutStream = { fileNo: posix/STDOUT };
  let STDERR: OutStream = { fileNo: posix/STDERR };

  impl Writer for OutStream {
    fn writeByte(self: Self, value: u8): unit {
      let* valueRef: *u8 = value;
      posix/write(fileNo = self.fileNo, data = valueRef as ptr, count = 1);
      ()
    }
    fn writeBytes(self: Self, bytes: View[byte]): unit {
      posix/write(
        fileNo = self.fileNo,
        data = bytes.dataPtr(),
        count = (bytes.len()) as c_sizet
      );
      ()
    }
  }
}

ns sys {

  fn printBacktrace(): unit {
    if not k1/IS_STATIC {
      k1rt/_k1_show_backtrace();
    }
  }

  #if k1/OS_MACOS extern("arc4random_uniform") fn arc4random_uniform(upperBound: u32): u32

  fn random(upperBound: u32): u32 {
    #if k1/OS == "macos" arc4random_uniform(upperBound)
    else if k1/OS == "linux" crash("linux 'random' unimpl")
    else if k1/OS == "wasm" crash("wasm 'random' unimpl")
    else crash("unreachable os")
  }

  fn parseMainArgs(argCount: u32, args: ptr): View[string] {
    let buf = Buffer/fromPtrAndCount[CString](
      count = argCount as size,
      pointer = args
    );
    let strings = for cstr in buf yield {
      string/wrapCString(cstr)
    };
    strings.asView()
  }

  fn readLine(maxLengthBytes: size): Result[string, string] {
    let* buffer = Buffer/_allocate[byte](maxLengthBytes);
    let bytesRead: i64 = posix/read(0, buffer.data as ptr, buffer.len as c_sizet);

    if bytesRead < 0 {
      return(.Err("Failed to read line"));
    };

    let length: size = bytesRead - 1;
    buffer.len* <- length;

    let result = string/wrapByteBuffer(buffer);
    .Ok(result)
  }

}

ns files {

  // nocommit(4): This is a mess switch to posix or something
  fn readToString(context alloc: mem/AllocMode)(path: string): string {
    let filenameCString = path.toCString();

    let file = libc/files/fopen(filenameCString.ptr, "r\0".toCString().ptr);
    if file.isNull() {
      crash("fopen failed: `{path}`");
    };
    libc/files/fseek(file, 0, libc/files/SEEK_END);
    let fileSizeBytes = libc/files/ftell(file);
    let buf = alloc.alloc(size = fileSizeBytes, align = 1);

    libc/files/fseek(file, 0, libc/files/SEEK_SET);
    libc/files/fread(buf, fileSizeBytes, 1, file);
    let string = string/wrapBuffer(
      Buffer/fromPtrAndCount(count = fileSizeBytes, pointer = buf)
    );
    libc/files/fclose(file);

    alloc.free(ptr = filenameCString.ptr, size = filenameCString.len + 1, align = 1);

    string
  }
}

fn assertMsg(context locn: compiler/SourceLocation)(msg: string, value: bool): unit {
  if not value {
    crash("ASSERT FAILED: {msg}")
  };
}

ns char {
  fn toString(self: char): string {
    string/wrapList([self])
  }

  fn toDigitValue(self: char): ?u8 {
    let i_code = self as u8;
    if i_code >= 48 and i_code <= 57 {
      .Some(i_code - 48)
    } else {
      .None
    }
  }
}

impl[T: Print] Show for T {
  fn show(self: Self): string { 
    let* charList = List/empty[char]();
    self.printTo(charList);
    string/wrapList(charList)
  }
}


impl Print for bool {
  fn printTo[W: Writer](self: bool, w: W): unit { 
    let s = if self "true" else "false";
    w.writeString(s)
  }
}
// Direct specialized 'show' impl to avoid going through a buffer
impl Show for bool { fn show(self: bool): string { if self "true" else "false" } }
impl Print for char { fn printTo[W: Writer](self: char, w: W): unit { w.writeChar(self) } }
// Direct specialized 'show' impl to avoid going through a buffer
impl Show for char { fn show(self: char): string { self.toString() } }

fn formatUInt[W: Writer](context w: W)(value: u64, base: u64): unit {
  if value == 0 { w.writeChar('0'); return(()) }
  else if value < base {
    let digit = u8/toAsciiDigitBase(value as u8, base);
    w.writeChar(digit);
  } else if value < (base * 2) {
    let first = (value / base);
    let firstDigit = u8/toAsciiDigitBase(first as u8, base);
    let second = value % base;
    let secondDigit = u8/toAsciiDigitBase(second as u8, base);
    w.writeChar(firstDigit);
    w.writeChar(secondDigit);
  } else {
    let* remaining = value;
    // TODO(stdlib slow): Try to use stack space for small ones.
    let* digits = List/withCapacity[char](8);
    while remaining.* > 0 {
      let d = remaining.* % base;
      let c = u8/toAsciiDigitBase(d as u8, base);
      digits.push(c);
      remaining <- remaining.* / base;
    };

    digits.reverse();

    w.writeBytes(digits.asView().asByteView());

    ()
  }
}

impl Print for u8 {
  fn printTo[W: Writer](self: u8, w: W): unit {
    (self as u64).printTo(w)
  }
}

impl Print for u16 {
  fn printTo[W: Writer](self: u16, w: W): unit {
    (self as u64).printTo(w)
  }
}

impl Print for u32 {
  fn printTo[W: Writer](self: u32, w: W): unit {
    (self as u64).printTo(w)
  }
}

impl Print for u64 {
  fn printTo[W: Writer](self: u64, w: W): unit {
    formatUInt(context w)(self, base = 10);
  }
}

impl Print for i8 {
  fn printTo[W: Writer](self: i8, w: W): unit {
    (self as int).printTo(w)
  }
}

impl Print for i16 {
  fn printTo[W: Writer](self: i16, w: W): unit {
    (self as int).printTo(w)
  }
}

impl Print for i32 {
  fn printTo[W: Writer](self: i32, w: W): unit {
    (self as int).printTo(w)
  }
}

impl Print for int {
  fn printTo[W: Writer](self: int, w: W): unit {
    let neg = self < 0;
    if neg {
      w.writeChar('-');
    };

    let pos = if neg { (self * -1) } else self;
    formatUInt(context w)(pos as uint, 10);
  }
}

impl[S, F: Print] Try[T = S, E = F] for Result[S, F] {
  fn error(e: E): Self { .Err(e) }
  fn value(t: T): Self    { .Ok(t) }

  fn isOk(self: Self): bool { self is .Ok(_) }
  fn getValue(self: Self): T  { 
    switch self {
      .Ok(s) -> s,
      .Err(e) -> crash("getValue() on .Err: {e}")
    }
  }
  fn getError(self: Self): E { 
    switch self {
      .Ok(_) -> crash("getError() on .Ok"),
      .Err(e) -> e
    }
  }
}

impl[S, F] Try[T = S, E = F] for Result[S, F] {
  fn error(e: E): Self { .Err(e) }
  fn value(t: T): Self    { .Ok(t) }

  fn isOk(self: Self): bool { self is .Ok(_) }
  fn getValue(self: Self): T  { 
    switch self {
      .Ok(s) -> s,
      .Err(e) -> crash("getValue() on .Err")
    }
  }
  fn getError(self: Self): E { 
    switch self {
      .Ok(_) -> crash("getError() on .Ok"),
      .Err(e) -> e
    }
  }
}

impl Comparable for i64 {
  fn compare(self: i64, other: i64): Ordering {
    if self == other .Equal else if self > other .Greater else .Less
  }
}

impl Comparable for u64 {
  fn compare(self: u64, other: u64): Ordering {
    if self == other .Equal else if self > other .Greater else .Less
  }
}

impl Comparable for u8 {
  fn compare(self: u8, other: u8): Ordering {
    if self == other .Equal else if self > other .Greater else .Less
  }
}

ns u8 {
  fn toAsciiDigitBase(v: u8, base: u64): char {
    if v < 10 {
      (v + 48) as char // '0' + v
    } else if v < 36 {
      (v + 87) as char // 'a' + (v - 10)
    } else if v < 62 {
      (v + 29) as char // 'A' + (v - 36)
    } else {
      crash("u8/toAsciiDigitBase: value {v} is out of range for base {base}")
    }
  }
  fn toAsciiDigit(v: u8): char {
    (v + 48) as char
  }
}

ns k1rt {
  // TODO: Add ".c" dependency support; so we can go back to single compilation unit for k1rt:
  // extern("k1rt.c", "_k1_show_backtrace") fn _k1_show_backtrace(): unit
  // Allowing you to mix and match .c and .k1 files

  extern("k1rt", "_k1_show_backtrace") fn _k1_show_backtrace(): unit
  extern("k1rt", "_k1_snprintf_f32") fn snprintf_f32(buf: ptr, size: c_sizet, float: f32, places: u32): i32
  extern("k1rt", "_k1_snprintf_f64") fn snprintf_f64(buf: ptr, size: c_sizet, float: f64, places: u32): i32
}

ns f64 {
  fn format[W: Writer](f: f64, w: W, places: u32): unit {
    let* stackBuf = Array/bytes[32]();
    let writtenLen: i32 = k1rt/snprintf_f64(stackBuf.getBase() as ptr, 32, f, places);
    if writtenLen <= 0 crash("snprintf_f32 returned {writtenLen}");
    w.writeBytes(stackBuf.asView().slice(0, writtenLen as size))
  }
}

impl Equals for f32 { intern fn equals(self: f32, other: f32): bool }
impl Equals for f64 { intern fn equals(self: f64, other: f64): bool }

impl Add for f32 { intern fn add(self: Self, other: Self): Self }
impl Add for f64 { intern fn add(self: Self, other: Self): Self }

impl Sub for f32 { intern fn sub(self: Self, other: Self): Self }
impl Sub for f64 { intern fn sub(self: Self, other: Self): Self }

impl Mul for f32 { intern fn mul(self: Self, other: Self): Self }
impl Mul for f64 { intern fn mul(self: Self, other: Self): Self }

impl Div for f32 { intern fn div(self: Self, other: Self): Self }
impl Div for f64 { intern fn div(self: Self, other: Self): Self }

impl Rem for f32 { intern fn rem(self: Self, other: Self): Self }
impl Rem for f64 { intern fn rem(self: Self, other: Self): Self }

impl ScalarCmp for f32 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for f64 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}

impl Print for f32 {
  fn printTo[W: Writer](self: f32, w: W): unit {
    f64/format(self as f64, w, places = 6);
  }
}

impl Print for f64 {
  fn printTo[W: Writer](self: f64, w: W): unit {
    f64/format(self, w, places = 6);
  }
}

impl Print for ptr {
  fn printTo[W: Writer](self: ptr, w: W): unit {
    w.writeString("0x");
    formatUInt(context w)(self as usize, base = 16);
  }
}
