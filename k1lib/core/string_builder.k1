// Copyright (c) 2025 knix
// All rights reserved.

// This is an interesting pattern that may or may not hold up
// over time, of wrapping the pointer in a struct
// so that we can just pass around a StringBuilder
// which is of course always mutable and always 'by reference'

// We used to do a sort of 'linked list' of string or char segments
// which I think is probably more performant, come to think of it,
// than just a growing buffer
deftype StringBuilder = { charList: *mut List[char] }
ns StringBuilder {
  deftype alias Part = StringBuilder.charList.value.T

  fn withCapacity(cap: uword): StringBuilder {
    let charList = mem/new(List/withCapacity[Part](cap));
    { charList: charList }
  }

  fn new(): StringBuilder {
    withCapacity(0)
  }

  fn putChar(self: StringBuilder, c: char): unit {
    self.charList.push(c)
  }
  fn putString(self: StringBuilder, s: string): unit {
    // TODO(stdlib): Need an appendBufferCopy, or similarly
    // to solve for the 'copy' vs 'non-copy' problem
    self.charList.appendView(
      s.view()
    )
  }
  fn putByte(self: StringBuilder, b: byte): unit {
    self.charList.push(b as char)
  }
  fn build(self: StringBuilder): string {
    string/wrapList(self.charList)
  }
}

impl Writer for StringBuilder {
  fn writeChar(self: Self, value: char): unit {
    self.putChar(value)
  }
  fn writeByte(self: Self, value: u8): unit {
    self.putByte(value)
  }
  fn writeString(self: Self, value: string): unit {
    self.putString(value)
  }
  fn writeBytes(self: Self, bytes: View[byte]): unit {
    self.putString(string/fromBytes(bytes))
  }
}
