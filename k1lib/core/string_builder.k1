// Copyright (c) 2025 knix
// All rights reserved.

// This is an interesting pattern that may or may not hold up
// over time, of wrapping the pointer in a struct
// so that we can just pass around a StringBuilder
// which is of course always mutable and always 'by reference'
deftype StringBuilder = { charList: *write List[char] }
ns StringBuilder {
  deftype alias Part = StringBuilder.charList.value.T

  fn withCapacity(cap: uword): StringBuilder {
    let charList = mem/new(List/withCapacity[Part](cap));
    { charList: charList }
  }

  fn new(): StringBuilder {
    withCapacity(0)
  }

  fn putChar(self: StringBuilder, c: char): unit {
    self.charList.push(c)
  }
  fn putString(self: StringBuilder, s: string): unit {
    // TODO(stdlib): Need an appendBufferCopy, or similarly
    // to solve for the 'copy' vs 'non-copy' problem
    self.charList.appendView(
      s.view()
    )
  }
  fn putByte(self: StringBuilder, b: byte): unit {
    self.charList.push(b as char)
  }
  fn build(self: StringBuilder): string {
    string/wrapList(self.charList)
  }
}
