// Copyright (c) 2025 knix
// All rights reserved.

// This is an interesting pattern that may or may not hold up
// over time, of wrapping the pointer in a struct
// so that we can just pass around a StringBuilder
// which is of course always mutable and always 'by reference'

// We used to do a sort of 'linked list' of string or char segments
// which I think is probably more performant, come to think of it,
// than just a growing buffer
deftype StringBuilder = { charList: *mut List[char] }
ns StringBuilder {

  fn withCapacity(cap: uword): StringBuilder {
    let charList = mem/new(List/withCapacity[char](cap));
    { charList: charList }
  }

  fn new(): StringBuilder {
    withCapacity(0)
  }

  fn putChar(self: StringBuilder, c: char): unit {
    self.charList.push(c)
  }
  fn putString(self: StringBuilder, s: string): unit {
    self.charList.appendView(s.view())
  }
  fn putByte(self: StringBuilder, b: byte): unit {
    self.charList.push(b as char)
  }
  fn build(self: StringBuilder): string {
    let s = string/wrapList(self.charList);
    self.charList.clear();
    s
  }
}

impl Writer for StringBuilder {
  fn writeByte(self: Self, value: u8): unit {
    self.putByte(value)
  }
  fn writeBytes(self: Self, bytes: View[byte]): unit {
    self.putString(string/fromBytes(bytes))
  }
}
