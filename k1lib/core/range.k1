// Copyright (c) 2025 knix
// All rights reserved.

deftype IntRange = { start: int, end: int }
ns IntRange {
  fn make(start: int, end: int): IntRange { { start, end } }
  fn upTo(end: int): IntRange { { start: 0, end } }
}
deftype IntRangeIterator = { range: IntRange, offset: int }

ns IntRangeIterator {
  fn make(range: IntRange): IntRangeIterator { { range, offset: 0 } }

  fn position(self: IntRangeIterator): int { self.range.start + self.offset }
  fn size(self: IntRangeIterator): int { self.range.end - self.range.start }
  fn stepBy(self: *mut IntRangeIterator, n: size): bool { 
    let nextPos = self.position() + n;
    if nextPos >= self.range.end false else {
      self.offset* <- self.offset + n;
      true
    }
  }
  fn current(self: IntRangeIterator): int {
    self.range.start + self.offset
  }
}

impl Iterator[Item = int] for IntRangeIterator {
  fn peek(self: *Self): ?int {
     if self.position() >= self.range.end {
       .None
     } else {
       let current = self.current();
       .Some(current)
     }
  }
  fn sizeHint(self: *Self): { atLeast: size, atMost: ?size } {
    let remaining = self.range.end - self.position();
    { atLeast: remaining, atMost: .Some(remaining) }
  }
  fn advanceBy(self: *mut Self, n: size): unit {
    self.stepBy(n);
    ()
  }
  fn nth(self: *mut Self, n: size): ?size {
    self.stepBy(n); 
    self.next()
  }
}

impl Iterable[Item = int, I = IntRangeIterator] for IntRange {
  fn iterator(self: IntRange): IntRangeIterator { IntRangeIterator/make(self) }
}
