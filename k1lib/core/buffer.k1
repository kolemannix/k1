// Copyright (c) 2025 knix
// All rights reserved.

// Represents a contiguously allocated segment of memory that
// is alleged to store values of type T. This is an inherently
// unsafe type as all of the memory is not guaranteed to be populated
//
// I'm going to introduce a safe wrapper around it that is meant to be used
// as your 'slice' type, and we'll rename this, perhaps, to RawBuffer
// It'll be the same thing except for a 'Promise' from the creator that
// it's fully populated
ns Buffer {

  fn bufferSizeBytes[T](count: uword): uword {
    count * core/types/sizeOfStride[T]()
  }

  fn sizeBytes[T](self: Buffer[T]): uword { bufferSizeBytes[T](self.len) }

  fn dataPtr[T](self: Buffer[T]): ptr { self.data as ptr }

  ////////////////////////
  // Constructor functions

  fn empty[T](): Buffer[T] {
    { len: 0, data: ptr/NULL as *mut T }
  }

  fn fromPtrAndCount[T](pointer: ptr, count: uword): Buffer[T] {
    { len: count, data: pointer as *mut T }
  }

  fn fromRefAndCount[T](len: uword, data: *mut T): Buffer[T] {
    { len: len, data }
  }

  fn wrapArray[T, N: static uword](array: *mut Array[T, N]): Buffer[T] {
    let base = array.getBase();
    let l = array.len();
    let wrapped = fromRefAndCount(l, array.getBase());
    wrapped
  }

  fn copyFromArray[T, N: static uword](array: *Array[T, N]): Buffer[T] {
    let base = array.getBaseRead();
    let l = array.len();
    let wrapped = wrapArray[T, N](array.toMut);
    wrapped.cloned();
  }

  fn copyFromView[T](view: View[T]): Buffer[T] {
    view.innerBuffer().cloned()
  }

  fn cloned[T](self: Buffer[T]): Buffer[T] {
    let clone = self._enlargedClone(newCount = self.len);
    clone
  }

  fn filledIn[T](context mode: mem/AllocMode)(size: uword, value: T): Buffer[T] {
    let buf: Buffer[T] = _allocateIn[T](size);

    // TODO: Make this specialization possible
    //#if types/getTypeSchema[T]() is .Int(.U8) or .Int(.I8) {
    //  let valueU8 = meta/typeAssert[T, u8](value);
    //  println("specialized memset in Buffer/filledIn");
    //  mem/set(dst = buf.dataPtr(), value = value, count = size)
    //} else {
    //println("unspecialized Buffer/filledIn");
      let i = 0uword;
      while i < size {
        buf.getRefUnchecked(i) <- value;
        i := i + 1;
      };
    //};
    buf
  }

  fn filled[T](size: uword, value: T): Buffer[T] {
    Buffer/filledIn[T](context .Current)(size, value)
  }

  fn _allocateIn[T](context alloc: mem/AllocMode)(count: uword): Buffer[T] {
    let ptr = if count == 0 {
      ptr/NULL
    } else {
      let sizeBytes = bufferSizeBytes[T](count);
      alloc.alloc(sizeBytes, core/types/alignOf[T]())
    };
    let data = ptr as *mut T;
    { len: count, data }
  }

  fn _allocate[T](count: uword): Buffer[T] {
    _allocateIn[T](context .Current)(count)
  }

  ////////////////////////
  // Modification

  fn _growTo[T](context alloc: mem/AllocMode)(self: *mut Buffer[T], newCount: uword): unit {
    if alloc.resolve().supportsRealloc() {
      let newSize = bufferSizeBytes[T](newCount);
      let oldSize = bufferSizeBytes[T](self.len);
      let newPtr = alloc.realloc(
        ptr = self.dataPtr(),
        oldSize = oldSize,
        align = core/types/alignOf[T](),
        newSize = newSize,
      );
      self <- { len: newCount, data: newPtr as *mut T }
    } else {
      let newBuffer = self._enlargedCloneIn(newCount);
      self <- newBuffer
    }
  }

  fn _enlargedCloneIn[T](context alloc: mem/AllocMode)(self: Buffer[T], newCount: uword): Buffer[T] {
    let newBuffer = _allocateIn[T](newCount);
    copyFrom[T](src = self, dst = newBuffer);
    newBuffer
  }

  fn _enlargedClone[T](self: Buffer[T], newCount: uword): Buffer[T] {
    _enlargedCloneIn[T](context .Current)(self, newCount)
  }

  fn copyFrom[T](src: Buffer[T], dst: Buffer[T]): unit {
    if src.len > dst.len {
      crash("Buffer copy dst index out of bounds: {src.len} > {dst.len}")
    };
    let numBytes = bufferSizeBytes[T](src.len);
    mem/copy(dst = dst.dataPtr(), src = src.dataPtr(), count = numBytes);
    ()
  }

  fn clonedIn[T](context mode: mem/AllocMode)(self: Buffer[T]): Buffer[T] {
    let clone = self._enlargedCloneIn(newCount = self.len);
    clone
  }

  ///////////////////////////
  // Accessor functions

  fn getRefRead[T](self: Buffer[T], index: uword): *T {
    self.getRef[T](index) as *T
  }

  fn getRefUnchecked[T](self: Buffer[T], index: uword): *mut T {
    self.dataPtr().refAtIndex[T](index)
  }

  fn getRef[T](self: Buffer[T], index: uword): *mut T {
    if index >= self.len {
      crash("index out of bounds: {index} >= {self.len}")
    };
    self.getRefUnchecked[T](index)
  }

  fn set[T](self: Buffer[T], index: uword, elem: T): unit {
    let tRef = self.getRef(index);
    tRef <- elem;
  }

  fn memset[T](self: Buffer[T], value: u8): unit {
    mem/set(
      dst = self.dataPtr(),
      value = value,
      count = self.len
    );
  }

  fn get[T](self: Buffer[T], index: uword): T {
    let tRef = self.getRef(index);
    tRef.*
  }

  fn slice[T](self: Buffer[T], start: uword, end: uword): Buffer[T] {
    if end < start or self.len == 0 {
      return(empty[T]())
    };
    if start >= self.len or start < 0 {
      let len = self.len;
      crash("slice start index out of bounds: {start}. length is: {len}")
    };
    let end = if end > self.len self.len else end;
    let newLen = end - start;
    let newBase = self.getRef(start);
    { len: newLen, data: newBase }
  }

  fn take[T](self: Buffer[T], count: uword): Buffer[T] { self.slice(0,     count) }
  fn drop[T](self: Buffer[T], count: uword): Buffer[T] { self.slice(count, self.len) }

  fn isEmpty[T](self: Buffer[T]): bool {
    self.len == 0
  }

  fn nonEmpty[T](self: Buffer[T]): bool {
    self.len > 0
  }

  fn firstRef[T](self: Buffer[T]): ?(*mut T) {
    if not self.isEmpty() {
      .Some(self.getRef(0))
    } else {
      .None
    }
  }

  fn first[T](self: Buffer[T]): ?T {
    switch self.firstRef() {
      .None -> .None,
      .Some(firstRef) -> .Some(firstRef.*)
    }
  }

  fn lastRef[T](self: Buffer[T]): ?(*mut T) {
    if not self.isEmpty() {
      .Some(self.getRef(self.len - 1))
    } else {
      .None
    }
  }

  fn last[T](self: Buffer[T]): ?T {
    switch self.lastRef() {
      .None -> .None,
      .Some(lastRef) -> .Some(lastRef.*)
    }
  }

  fn concat[T](self: Buffer[T], other: Buffer[T]): Buffer[T] {
    let new = self._enlargedClone[T](self.len + other.len);
    copyFrom(
      src = other, 
      dst = new.slice(self.len, self.len + other.len), 
    );
    new
  }

  fn swap[T](self: *mut Buffer[T], indexA: uword, indexB: uword): unit {
    if indexA == indexB { return() };
    let aRef = self.*.getRef(indexA);
    let bRef = self.*.getRef(indexB);
    let bValue = bRef.*;
    bRef <- aRef.*;
    aRef <- bValue;
  }

  fn sorted[T](self: Buffer[T]): Buffer[T] where T: Comparable {
    let* list = List/wrapBuffer(self);
    list.sort();
    list.asBuffer()
  }

  fn toCharBuffer(self: Buffer[byte]): Buffer[char] {
    Buffer/fromPtrAndCount[char](
      count = self.len,
      pointer = self.dataPtr()
    );
  }

  fn asByteBuffer(self: Buffer[char]): Buffer[byte] {
    Buffer/fromPtrAndCount[byte](
      count = self.len,
      pointer = self.dataPtr()
    );
  }

  fn refIter[T](self: Buffer[T]): BufferRefIterator[T] {
    BufferRefIterator/fromBuffer(self)
  }

}

deftype BufferIterator[T] = {
  buf: Buffer[T],
  pos: uword
}
ns BufferIterator {
  fn fromBuffer[T](buf: Buffer[T]): BufferIterator[T] { 
    { buf, pos: 0 }
  }
}

impl[T] Iterator[Item = T] for BufferIterator[T] {
  fn next(self: *mut BufferIterator[T]): ?Item { 
    if self.pos < self.buf.len {
      let item = self.buf.get(self.pos);
      self.pos* <- self.pos + 1;
      some(item)
    } else .None
  }
  fn sizeHint(self: *Self): { atLeast: uword, atMost: ?uword } { 
    let rem = self.buf.len - self.pos;
    { atLeast: rem, atMost: some(rem) }
  }
  fn advanceBy(self: *mut Self, n: uword): unit {
    self.pos* <- self.pos + n
  }
  fn nth(self: *mut Self, n: uword): ?Item {
    self.advanceBy(n);
    self.next()
  }
}

impl[T] Iterable[Item = T, I = BufferIterator[T]] for Buffer[T] {
  fn iterator(self: Self): I {
    BufferIterator/fromBuffer(self)
  }
}

impl[T: Print] Print for Buffer[T] {
  fn printTo[W: Writer](self: Self, w: W): unit {
    w.writeChar('[');
    for self do {
      it.printTo(w);
      let last = itIndex == self.len - 1;
      if not last {
        w.writeChar(',');
      };
    };
    w.writeChar(']');
  }
}

deftype BufferRefIterator[T] = {
  buf: Buffer[T],
  pos: uword
}
ns BufferRefIterator {
  fn fromBuffer[T](buf: Buffer[T]): BufferRefIterator[T] { 
    { buf, pos: 0 }
  }
}

impl[T] Iterator[Item = *mut T] for BufferRefIterator[T] {
  fn next(self: *mut BufferRefIterator[T]): ?Item { 
    if self.pos < self.buf.len {
      let item = self.buf.getRef(self.pos);
      self.pos* <- self.pos + 1;
      some(item)
    } else .None
  }
  fn sizeHint(self: *Self): { atLeast: uword, atMost: ?uword } { 
    let rem = self.buf.len - self.pos;
    { atLeast: rem, atMost: some(rem) }
  }
  fn advanceBy(self: *mut Self, n: uword): unit {
    self.pos* <- self.pos + n
  }
  fn nth(self: *mut Self, n: uword): ?Item {
    self.advanceBy(n);
    self.next()
  }
}
