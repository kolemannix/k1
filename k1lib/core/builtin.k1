// Copyright (c) 2025 knix
// All rights reserved.

// Only code that is necessary for the compiler's operation
// belongs in this file

///////////
// Types //
deftype u8  = builtin
deftype u16 = builtin
deftype u32 = builtin
deftype u64 = builtin
deftype uword = builtin
deftype i8  = builtin
deftype i16 = builtin
deftype i32 = builtin
deftype i64 = builtin
deftype iword = builtin

deftype unit    = builtin
deftype char    = builtin
deftype bool    = builtin

/// An uninhabited type representing that code with this type never returns
/// Used to signal termination and enables control flow analysis
deftype never   = builtin

deftype ptr = builtin

deftype f32 = builtin
deftype f64 = builtin

deftype Buffer[T] = { len: uword, data: *mut T }

deftype View[T] = { buffer: Buffer[T] }

deftype List[T] = { len: uword, buffer: Buffer[T] }
deftype string = { view: View[char] }

deftype Opt[T] = either None, Some(T)

ns compiler {
  deftype SourceLocation = { filename: string, line: u64 }
}

deftype Ordering = either Less, Equal, Greater

deftype Result[T, E] = either Ok(T), Err(E)

deftype alias int = iword
deftype alias uint = uword
deftype alias byte = u8

ns types {
  intern fn typeId[T](): u64

  intern fn typeSchema(id: u64): TypeSchema
  intern fn typeName(id: u64): string

  fn getTypeName[T](): string { typeName(typeId[T]()) }
  fn getTypeNameOfVal[T](t: T): string { typeName(typeId[T]()) }
  fn getTypeSchema[T](): TypeSchema { typeSchema(typeId[T]()) }

  // DO NOT REORDER VARIANTS
  deftype IntKind = either U8, U16, U32, U64, I8, I16, I32, I64

  // DO NOT REORDER VARIANTS
  deftype IntValue = either
    U8(u8), U16(u16), U32(u32), U64(u64),
    I8(i8), I16(i16), I32(i32), I64(i64)

  deftype Layout = { size: uword, align: uword }

  deftype TypeSchema = (either
    Unit,
    Char,
    Int(IntKind),
    Word(either UWord, IWord),
    Float(either F32, F64),
    Bool,
    Ptr,
    String,
    Reference({ innerTypeId: u64, mutable: bool }),
    Array({
      elementTypeId: u64,
      size: ?uword
    }),
    Struct({
      fields: View[{
        name: string,
        typeId: u64,
        offset: uword
      }],
    }),
    Either({
      tagType: IntKind,
      variants: View[{
        name: string,
        tag: IntValue,
        payload: ?{ typeId: u64, offset: uword }
      }],
    }),
    Variant({
      enumTypeId: u64,
      name: string,
    }),
    Function({
      params: View[{ name: string, typeId: u64 }],
      returnTypeId: u64,
    }),
    FunctionPointer({ functionTypeId: u64 }),
    // TODO: lambda schema, lambda object schema
    // Lambda({ typeId: u64, functionTypeId: u64 }),
    // LambdaObject({ functionTypeId: u64 }),
    Never,
    Other(string)
  )

  deftype Any = {
    typeId: u64,
    value: ptr
  }


  fn makeAny[T](t: *T): Any {
    { typeId: typeId[T](), value: t as ptr }
  }

}

ns meta {

  /////// Static value ferrying across the runtime/comptime border:
  /////// Likely marked internal eventually
  intern fn bakeStaticValue[T](value: T): u64
  // Must be provided an integer literal.
  // Can only be called by generated code
  intern fn getStaticValue[T](id: u64): T

  intern fn staticTypeToValue[T, ST: static T](): T

}

////////////////////////////////
// Built-in Abilities

// Equals must have ability id 0
ability Equals {
  fn equals(self: Self, other: Self): bool
}

// TODO(dogfood): Enhance with an `impl Error` type parameter
// TODO(dogfood): Allow Error = never for infallible writes
ability Writer {
  fn writeByte(self: Self, value: u8): unit 
  fn writeBytes(self: Self, bytes: View[byte]): unit

  fn writeChar(self: Self, value: char): unit { self.writeByte(value as u8) }
  fn writeString(self: Self, value: string): unit { self.writeBytes(value.viewBytes()) }
}

ability Print {
  fn printTo[W: Writer](self: Self, w: W): unit
}

// Show must have ability id 4
// TODO: Show does not belong in k1 long term because it says nothing about where the data
//       is allocated, and the name is too Haskelly, which is to say
//       both erudite and pedestrian at the same time? Looking at you,
//       'Just'
//       POSSIBLY we could keep it as like To(Temp)String
ability Show {
  fn show(self: Self): string
}

ability Bitwise {
  fn bitNot(self: Self): Self
  fn bitAnd(self: Self, other: Self): Self
  fn bitOr(self: Self, other: Self): Self
  fn xor(self: Self, other: Self): Self

  fn shiftLeft(self: Self, count: uword): Self
  fn shiftRight(self: Self, count: uword): Self
}

ability Add { fn add(self: Self, rhs: Self): Self }
ability Sub { fn sub(self: Self, rhs: Self): Self }
ability Mul { fn mul(self: Self, rhs: Self): Self }
ability Div { fn div(self: Self, rhs: Self): Self }
ability Rem { fn rem(self: Self, rhs: Self): Self }

// I understand this is a 'Closed', more simple notion of Add
// than Rust's std::ops::Add, generic over Rhs and Output. However,
// being able to assume a symmetric add gives us much better and simpler
// type inference for 99% of cases. If we ever do Defaults, where
// we could default Rhs and Output to Self, and also somehow use
// that information while inferring... then maybe. But I don't want
// to achieve it by doing "try the call with every impl" for performance reasons
impl Add for u8  {   intern fn add(self: Self, rhs: Self): Self }
impl Add for u16 {   intern fn add(self: Self, rhs: Self): Self }
impl Add for u32 {   intern fn add(self: Self, rhs: Self): Self }
impl Add for u64 {   intern fn add(self: Self, rhs: Self): Self }
impl Add for i8  {   intern fn add(self: Self, rhs: Self): Self }
impl Add for i16 {   intern fn add(self: Self, rhs: Self): Self }
impl Add for i32 {   intern fn add(self: Self, rhs: Self): Self }
impl Add for i64 {   intern fn add(self: Self, rhs: Self): Self }
impl Add for uword { intern fn add(self: Self, rhs: Self): Self }
impl Add for iword { intern fn add(self: Self, rhs: Self): Self }

impl Sub for u8  {   intern fn sub(self: Self, rhs: Self): Self }
impl Sub for u16 {   intern fn sub(self: Self, rhs: Self): Self }
impl Sub for u32 {   intern fn sub(self: Self, rhs: Self): Self }
impl Sub for u64 {   intern fn sub(self: Self, rhs: Self): Self }
impl Sub for i8  {   intern fn sub(self: Self, rhs: Self): Self }
impl Sub for i16 {   intern fn sub(self: Self, rhs: Self): Self }
impl Sub for i32 {   intern fn sub(self: Self, rhs: Self): Self }
impl Sub for i64 {   intern fn sub(self: Self, rhs: Self): Self }
impl Sub for uword { intern fn sub(self: Self, rhs: Self): Self }
impl Sub for iword { intern fn sub(self: Self, rhs: Self): Self }

impl Mul for u8    { intern fn mul(self: Self, rhs: Self): Self }
impl Mul for u16   { intern fn mul(self: Self, rhs: Self): Self }
impl Mul for u32   { intern fn mul(self: Self, rhs: Self): Self }
impl Mul for u64   { intern fn mul(self: Self, rhs: Self): Self }
impl Mul for i8    { intern fn mul(self: Self, rhs: Self): Self }
impl Mul for i16   { intern fn mul(self: Self, rhs: Self): Self }
impl Mul for i32   { intern fn mul(self: Self, rhs: Self): Self }
impl Mul for i64   { intern fn mul(self: Self, rhs: Self): Self }
impl Mul for uword { intern fn mul(self: Self, rhs: Self): Self }
impl Mul for iword { intern fn mul(self: Self, rhs: Self): Self }
  
impl Div for u8    { intern fn div(self: Self, rhs: Self): Self }
impl Div for u16   { intern fn div(self: Self, rhs: Self): Self }
impl Div for u32   { intern fn div(self: Self, rhs: Self): Self }
impl Div for u64   { intern fn div(self: Self, rhs: Self): Self }
impl Div for i8    { intern fn div(self: Self, rhs: Self): Self }
impl Div for i16   { intern fn div(self: Self, rhs: Self): Self }
impl Div for i32   { intern fn div(self: Self, rhs: Self): Self }
impl Div for i64   { intern fn div(self: Self, rhs: Self): Self }
impl Div for uword { intern fn div(self: Self, rhs: Self): Self }
impl Div for iword { intern fn div(self: Self, rhs: Self): Self }

impl Rem for u8    { intern fn rem(self: Self, rhs: Self): Self }
impl Rem for u16   { intern fn rem(self: Self, rhs: Self): Self }
impl Rem for u32   { intern fn rem(self: Self, rhs: Self): Self }
impl Rem for u64   { intern fn rem(self: Self, rhs: Self): Self }
impl Rem for i8    { intern fn rem(self: Self, rhs: Self): Self }
impl Rem for i16   { intern fn rem(self: Self, rhs: Self): Self }
impl Rem for i32   { intern fn rem(self: Self, rhs: Self): Self }
impl Rem for i64   { intern fn rem(self: Self, rhs: Self): Self }
impl Rem for uword { intern fn rem(self: Self, rhs: Self): Self }
impl Rem for iword { intern fn rem(self: Self, rhs: Self): Self }

ability ScalarCmp {
  fn lt(self: Self, other: Self): bool
  fn le(self: Self, other: Self): bool
  fn gt(self: Self, other: Self): bool
  fn ge(self: Self, other: Self): bool
}

impl ScalarCmp for u8 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for u16 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for u32 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for u64 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for uword {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for i8 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for i16 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for i32 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for i64 {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}
impl ScalarCmp for iword {
  intern fn lt(self: Self, other: Self): bool
  intern fn le(self: Self, other: Self): bool
  intern fn gt(self: Self, other: Self): bool
  intern fn ge(self: Self, other: Self): bool
}

ability Comparable {
  fn compare(self: Self, other: Self): Ordering
}

ability Unwrap[impl Inner] {
  fn hasValue(self: Self): bool
  fn unwrap(self: Self): Inner
  fn make(inner: Inner): Self
}

ability Try[impl T, impl E] {
  // DO NOT REORDER `try` internal operation expects
  // makeError to be first! (FIXME)
  fn makeError(e: E): Self
  fn makeOk(t: T): Self

  fn isOk(self: Self): bool
  fn getError(self: Self): E
  fn getOk(self: Self): T
}

ability Iterator[impl Item] {
  fn next(self: *mut Self): ?Item
  fn sizeHint(self: *Self): { atLeast: uword, atMost: ?uword }
  fn advanceBy(self: *mut Self, n: uword): unit
  fn nth(self: *mut Self, n: uword): ?Item
}

ability Iterable[impl Item, impl I: Iterator[Item = Item]] {
  fn iterator(self: Self): I
}

/////////////////////////////////
// Code that we want to have available very early
// to enable basic comptime execution inside of builtin/core
// For example `if os == "macos"` requires string equality!

ns Buffer {
  fn equalsBits[T](self: Buffer[T], other: Buffer[T]): bool {
    if self.len == 0 and other.len == 0 true
    else if self.len != other.len       false else {
      mem/equals(self.dataPtr(), other.dataPtr(), self.sizeBytes())
    }
  }
}

ns View {
  fn equalsBits[T](self: View[T], other: View[T]): bool {
    self.buffer.equalsBits(other.buffer)
  }
}

impl Equals for Buffer[u8] {
  fn equals(self: Buffer[u8], other: Buffer[u8]): bool {
    self.equalsBits(other)
  }
}

impl Equals for Buffer[char] {
  fn equals(self: Buffer[char], other: Buffer[char]): bool {
    self.equalsBits(other)
  }
}

impl Equals for Buffer[int] {
  fn equals(self: Buffer[int], other: Buffer[int]): bool {
    self.equalsBits(other)
  }
}

impl Equals for Buffer[bool] {
  fn equals(self: Buffer[bool], other: Buffer[bool]): bool {
    self.equalsBits(other)
  }
}

impl Equals for View[u8] {
  fn equals(self: View[u8], other: View[u8]): bool {
    self.equalsBits(other)
  }
}

impl Equals for View[char] {
  fn equals(self: View[char], other: View[char]): bool {
    self.equalsBits(other)
  }
}

impl Equals for View[int] {
  fn equals(self: View[int], other: View[int]): bool {
    self.equalsBits(other)
  }
}

impl Equals for View[bool] {
  fn equals(self: View[bool], other: View[bool]): bool {
    self.equalsBits(other)
  }
}

impl Equals for string {
  fn equals(self: string, that: string): bool {
    self.view == that.view
  }
}

impl Print for string {
  fn printTo[W: Writer](self: string, w: W): unit { w.writeString(self) }
}

ns mem {

  // TODO: Possibly reduce to a single alloc with a 'zero' option to reduce the number of builtins
  intern fn alloc(size: uword, align: uword): ptr
  intern fn allocZeroed(size: uword, align: uword): ptr
  intern fn realloc(ptr: ptr, oldSize: uword, align: uword, newSize: uword): ptr
  intern fn free(ptr: ptr, size: uword, align: uword): unit

  intern fn copy(
    dst: ptr,
    src: ptr,
    count: uword
  ): unit
  intern fn set(
    dst: ptr,
    value: u8,
    count: uword
  ): unit
  intern fn equals(p1: ptr, p2: ptr, size: uword): bool

  intern fn zeroed[T](): T

}

/////////////////////////////////
// Compiler builtins
ns k1 {
  // IS_STATIC is set to 'true' when executing K1 code statically, at compile-time
  let IS_STATIC: bool = builtin;

  let TEST: bool = builtin;
  let NO_STD: bool = builtin;
  let DEBUG: bool = builtin;

  let OS: string = builtin; // Possible values: 'linux', 'macos', 'wasm'
  let OS_MACOS: bool = OS == "macos";
  let OS_POSIX: bool = OS == "macos" or OS == "linux";

  let MULTITHREADING: bool = builtin;

  intern fn emitCompilerMessage(
    locn: compiler/SourceLocation,
    level: (either(u8) Info, Warn, Error),
    msg: string
  ): unit

  deftype ModuleKind = either(u8) Library, Executable, Script

  deftype ModuleManifest = {
    kind: ModuleKind,
    deps: View[string],

    // Primary module settings
    multithreading: bool,
    libs: View[string],
  }

}

/////////////////////////////////
// Core sizing intrinsics

ns types {
  intern fn sizeOf[T](): uword
  intern fn sizeOfStride[T](): uword
  intern fn alignOf[T](): uword
}

ns compiler {
  intern fn location(): SourceLocation
}

ns sys {
  intern fn exit(code: i32): never
}

ns ptr {
  let NULL: ptr = 0: uword as ptr;

  fn isNull(self: ptr): bool {
    self as uword == 0
  }

  fn r[T](self: ptr): *T { self as *T }
  fn rw[T](self: ptr): *mut T { self as *mut T }

  // This is an intrinsic so that we can codegen a getelementptr
  // instruction in LLVM rather than a pointer cast.
  // But we _could_ do it in userland using sizeOf and arithmetic which is neat!
  intern fn refAtIndex[T](self: ptr, index: uword): *mut T

  fn addBytes(self: ptr, offset: uword): ptr { 
    (self as uword + offset) as ptr
  }

  fn subBytes(self: ptr, offset: uword): ptr { 
    (self as uword - offset) as ptr
  }

  fn diff(self: ptr, other: ptr): iword {
    (self as iword) - (other as iword)
  }

  fn alignAddr(baseAddress: uword, alignBytes: uword): uword {
    let mask = alignBytes - 1;
    Bitwise/bitAnd(baseAddress + mask, mask.bitNot())
  }

  fn aligned(self: ptr, alignBytes: uword): ptr {
    alignAddr(self as uword, alignBytes) as ptr
  }

}

impl Equals for ptr {
  fn equals(self: ptr, other: ptr): bool {
    self as uword == other as uword
  }
}

ns bool {
  intern fn negated(self: bool): bool
}

impl Equals for unit { fn equals(self: unit, other: unit): bool { true } }

impl Equals for bool { intern fn equals(self: bool, other: bool): bool }

impl Equals for u8 { intern fn equals(self: u8, other: u8): bool }
impl Equals for u16 { intern fn equals(self: u16, other: u16): bool }
impl Equals for u32 { intern fn equals(self: u32, other: u32): bool }
impl Equals for u64 { intern fn equals(self: u64, other: u64): bool }
impl Equals for uword { intern fn equals(self: Self, other: Self): bool }

impl Equals for i8 { intern fn equals(self: i8, other: i8): bool }
impl Equals for i16 { intern fn equals(self: i16, other: i16): bool }
impl Equals for i32 { intern fn equals(self: i32, other: i32): bool }
impl Equals for i64 { intern fn equals(self: i64, other: i64): bool }
impl Equals for iword { intern fn equals(self: Self, other: Self): bool }

impl Equals for char { intern fn equals(self: char, other: char): bool }

fn discard[T](t: T): unit { () }

ns Array {
  fn getBaseRead[T, N: static uword](array: *Array[T, N]): *T {
    array.getRef(0)
  }
  fn getBase[T, N: static uword](array: *mut Array[T, N]): *mut T {
    array.getRef(0)
  }
  fn basePtr[T, N: static uword](array: *mut Array[T, N]): ptr {
    array as ptr
  }
  fn sizeBytes[T, N: static uword](array: Array[T, N]): uword {
    types/sizeOf[Array[T, N]]()
  }

  fn zeroed[T, N: static uword](): Array[T, N] {
    mem/zeroed[Array[T, N]]()
  }

  fn bytes[N: static uword](): Array[u8, N] {
    mem/zeroed[Array[u8, N]]()
  }

  fn allocate[T, N: static uword](context alloc: mem/AllocMode)(): *mut Array[T, N] {
    alloc.allocT[Array[T, N]]()
  }

  fn memset[T, N: static uword](array: *mut Array[T, N], value: u8): unit {
    mem/set(dst = array.basePtr(), value = value, count = array.sizeBytes())
  }

  fn set[T, N: static uword](array: *mut Array[T, N], index: uword, value: T): unit {
    array.getRef(index) <- value
  }

  fn filledIn[T, N: static uword](context alloc: mem/AllocMode)(t: T, n: N): *mut Array[T, N] {
    let arrayUninit = allocate[T, N]();
    let i = 0uword;
    while i < n.fromStatic() {
      arrayUninit.getRef(i) <- t;
      i := i + 1uword;
    };
    arrayUninit
  }

  fn asBuffer[T, N: static uword](array: *mut Array[T, N]): Buffer[T] {
    let len: uword = array.len();
    { len, data: array.getBase() }
  }

  fn asView[T, N: static uword](array: *Array[T, N]): View[T] {
    let tempBuffer = array.toMut.asBuffer();
    View/wrapBuffer(tempBuffer)
  }

}

#if k1/OS_POSIX ns posix {

  let STDIN: i32 = 0;
  let STDOUT: i32 = 1;
  let STDERR: i32 = 2;

  extern("read") fn read(fileNo: i32, buffer: ptr, count: uword): iword
  extern("write") fn write(fileNo: i32, data: ptr, count: uword): iword
  
  // These may only hold on macos; temporary until we have a bindings generation system
  let MAP_FILE   : i32 = 0x0000;
  let MAP_SHARED : i32 = 0x0001;
  let MAP_PRIVATE: i32 = 0x0002;
  let MAP_FIXED  : i32 = 0x0010;
  // MAP_ANONYMOUS = 0x20 on Linux, but MAP_ANON = 0x1000 on macOS.
  let MAP_ANON   : i32 = (if k1/OS_MACOS 0x1000 else 0x20);

  // Pages may not be accessed.
  let PROT_NONE: i32 = 0x0;
  // Pages may be read.
  let PROT_READ: i32 = 0x1;
  // Pages may be written.
  let PROT_WRITE: i32 = 0x2;
  // Pages may be executed.
  let PROT_EXEC: i32 = 0x4;
  let MAP_FAILED: iword = -1;
  extern("mmap") fn mmap(addr: ptr, len: uword, prot: i32, flags: i32, fd: i32, offset: i64): ptr

  extern("munmap") fn munmap(addr: ptr, len: uword): i32

  let MADV_SEQUENTIAL: i32 = 2;
  extern("posix_madvise") fn madvise(addr: ptr, len: uword, advice: i32): i32

}

// Eventually: #if k1/C_RUNTIME
ns libc {

  extern("exit") fn exit(code: i32): never

  extern("memcmp") fn memcmp(s1: ptr, s2: ptr, size: uword): i32

  extern("malloc") fn malloc(size: uword): ptr
  extern("calloc") fn calloc(count: uword, size: uword): ptr
  extern("free") fn free(ptr: ptr): unit
  extern("realloc") fn realloc(ptr: ptr, size: uword): ptr

  extern("perror") fn perror(msg: ptr): unit

  ns files {
    let SEEK_END: i32 = 2;
    let SEEK_SET: i32 = 0;
    extern("fopen")  fn fopen(pathCString: ptr, modeCString: ptr): ptr
    extern("fseek")  fn fseek(fileDesc: ptr, offset: i64, whence: i32): i32
    extern("fread")  fn fread(buffer: ptr, size: uword, num: uword, stream: ptr): u64
    extern("fclose") fn fclose(fileDesc: ptr): i32
    extern("ftell")  fn ftell(fileDesc: ptr): i64
  }

}

fn assert(context locn: compiler/SourceLocation)(value: bool): unit {
  if not value { crash("ASSERT FAILED") };
}

fn assertdbg(context locn: compiler/SourceLocation)(value: bool): unit {
  #if k1/DEBUG
    if not value { crash("ASSERT FAILED") };
}

fn crash(context locn: compiler/SourceLocation)(msg: string): never {
  if k1/NO_STD {
    let s = "exiting (nostd)\n\0";
    posix/write(
      fileNo = 1,
      data = s.view().dataPtr(),
      count = s.view().len() - 1uword,
    );
    sys/exit(1)
  } else if k1/IS_STATIC {
    k1/emitCompilerMessage(locn, .Error, msg);
    sys/exit(111)
  } else {
    let filename = locn.filename;
    let line = locn.line;
    //sys/printBacktrace();
    let s = "{msg} at {filename}:{line}\n";
    eprint(s);
    sys/exit(1)
  }
}

fn crashBounds(context locn: compiler/SourceLocation)(size: uword, index: uword, msg: string): never {
  crash("{msg}: {index} >= {size}")
}

