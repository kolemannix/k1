// Copyright (c) 2025 knix
// All rights reserved.

use core/types/sizeOf
use core/types/alignOf

// TODO: Move to <header> . <mem block> model vs separate struct
deftype Arena = {
  basePtr: Pointer,
  curAddr: uword,
  maxAddr: uword
}
ns Arena {
  let mb: uword = 1048576;
  let gb: uword = 1073741824;

  fn regionSizeBytes(self: Arena): uword {
    self.maxAddr - (self.basePtr as uword)
  }

  // Aligns 'base' to the next available value that is aligned with `align`
  // TODO(optimize): alignTo: Learn from Rust's 'align_offset' impl
  fn alignTo(baseAddress: uword, alignBytes: uword): uword {
    let mask = alignBytes - 1;
    let sum = baseAddress + mask;
    let aligned = Bitwise/bitAnd(sum, Bitwise/bitNot(mask));
    #if k1/DEBUG if aligned != baseAddress {
      println("Aligned {baseAddress} to {aligned}!")
    };
    aligned
  }

  fn new(initialMb: uword): Arena {
    let capacity = initialMb * mb;
    // We zero the memory because we don't make arenas that often
    // so it's worth it
    let basePtr = mem/allocZeroed(
      size = capacity,
      align = 8
    );
    if basePtr.isNull() crash("calloc for Arena failed");
    {
      basePtr: basePtr,
      curAddr: basePtr as uword,
      maxAddr: basePtr as uword + capacity
    }
  }

  fn pushRaw(self: *mut Arena, size: uword, align: uword): Pointer {
    let dataStart = alignTo(self.curAddr, align);
    let newEnd = dataStart + size;
    if newEnd > self.maxAddr {
      crash("Arena is out of space to allocate {size} bytes. newEnd: {newEnd}. maxAddr: {self.maxAddr}")
    };

    self.curAddr* <- newEnd;
    dataStart as Pointer
  }

  fn pushUninit[T](self: *mut Arena): *mut T {
    let dataStart = self.pushRaw(sizeOf[T](), alignOf[T]());
    dataStart as *mut T
  }

  fn push[T](self: *mut Arena, t: T): *mut T {
    let dataStart = self.pushRaw(sizeOf[T](), alignOf[T]());

    let ref: *mut T = dataStart.rw();
    ref <- t;
    ref
  }

  fn freeAll(self: *mut Arena): unit {
    let size = self.regionSizeBytes();
    println("[arena] Freeing {size}");
    self.curAddr* <- (self.basePtr as uword);
  }
}
