// Copyright (c) 2025 knix
// All rights reserved.

use core/types/sizeOf
use core/types/alignOf

// TODO: Move to <header> . <mem block> model vs separate struct
deftype Arena = {
  basePtr: ptr,
  curAddr: ptr,
  maxAddr: ptr
}
ns Arena {
  let kb: size = 1024;
  let mb: size = 1048576;
  let gb: size = 1073741824;

  fn regionSizeBytes(self: Arena): size {
    self.maxAddr.diff(self.basePtr)
  }

  fn usedBytes(self: Arena): size {
    self.curAddr.diff(self.basePtr)
  }

  fn _virtual(usageHintMb: size): ptr {
    let basePtr: ptr = mem/virtualAlloc(gb);
    #if k1/DEBUG mem/set(dst = basePtr, value = 0xCD, count = usageHintMb * mb);
    posix/madvise(basePtr, (usageHintMb * mb) as c_sizet, advice = posix/MADV_SEQUENTIAL);
    basePtr
  }

  fn default(): Arena {
    let basePtr: ptr = _virtual(usageHintMb = 10);
    //let header: *mut Arena = basePtr as *mut Arena;
    //header.basePtr* <- basePtr.addBytes(types/sizeOf[Arena]());
    {
      basePtr: basePtr,
      curAddr: basePtr,
      maxAddr: basePtr.addBytes(gb)
    }
  }

  fn release(self: *mut Arena): unit {
    mem/virtualRelease(self.basePtr, self.regionSizeBytes())
  }

  fn reset(self: *mut Arena, clear: bool): unit {
    let usedBytes = self.usedBytes();
    println("[arena] Resetting {usedBytes / kb}KiB");
    self.curAddr* <- self.basePtr;

    if clear {
      println("mem/set clear {self.basePtr} 0 {usedBytes}");
      mem/set(dst = self.basePtr, value = 0, count = usedBytes);
    }
  }

  fn pushLayout(self: *mut Arena, size: size, align: size): ptr {
    let dataStart = self.curAddr.aligned(align);
    let newEnd = dataStart.addBytes(size);
    if newEnd as usize > self.maxAddr as usize {
      crash("Arena is out of space to allocate {size} bytes. newEnd: {newEnd}. maxAddr: {self.maxAddr}")
    };

    self.curAddr* <- newEnd;
    dataStart
  }

  fn pushUninit[T](self: *mut Arena): *mut T {
    let dataStart = self.pushLayout(sizeOf[T](), alignOf[T]());
    dataStart as *mut T
  }

  fn push[T](self: *mut Arena, t: T): *mut T {
    let dataStart = self.pushLayout(sizeOf[T](), alignOf[T]());

    let ref: *mut T = dataStart.rw();
    ref <- t;
    ref
  }

  fn pushN[T](self: *mut Arena, ts: View[T]): Buffer[T] {
    let size = ts.buffer.sizeBytes();
    let align = types/alignOf[T]();
    let base = self.pushLayout(size, align);
    let buffer: Buffer[T] = Buffer/fromPtrAndCount[T](base, ts.len());
    Buffer/copyFrom(src = ts.buffer, dst = buffer);
    buffer
  }

  fn pushString(self: *mut Arena, s: string): string {
    let data: Buffer[char] = self.pushN(s.view());
    string/wrapBuffer(data)
  }

  fn pushList[T](self: *mut Arena, cap: size): List[T] {
    List/withCapacityIn(context .CustomArena(self))(cap)
  }

}
