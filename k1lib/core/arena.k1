// Copyright (c) 2025 knix
// All rights reserved.

use core/types/sizeOf
use core/types/alignOf

// TODO: Move to <header> . <mem block> model vs separate struct
deftype Arena = {
  basePtr: Pointer,
  curAddr: uword,
  maxAddr: uword
}
ns Arena {
  let kb: uword = 1024;
  let mb: uword = 1048576;
  let gb: uword = 1073741824;

  fn regionSizeBytes(self: Arena): uword {
    self.maxAddr - (self.basePtr as uword)
  }

  fn usedBytes(self: Arena): uword {
    self.curAddr - (self.basePtr as uword)
  }

  fn _virtual(usageHintMb: uword): Pointer {
    let basePtr: Pointer = mem/virtualAlloc(gb);
    #if k1/DEBUG mem/set(dst = basePtr, value = 0xCD, count = usageHintMb * mb);
    // nocommit arena advise sequential
    // posix/madvise();
    basePtr
  }

  fn default(): Arena {
    println("making arena");
    let basePtr: Pointer = if k1/IS_STATIC mem/alloc(size = 10 * mb, align = 8) else _virtual(usageHintMb = 10);
    //let header: *mut Arena = basePtr as *mut Arena;
    //header.basePtr* <- basePtr.addBytes(types/sizeOf[Arena]());
    {
      basePtr: basePtr,
      curAddr: basePtr as uword,
      maxAddr: basePtr.addBytes(gb) as uword
    }
  }

  fn release(self: *mut Arena): unit {
    mem/virtualRelease(self.basePtr, self.regionSizeBytes())
  }

  fn reset(self: *mut Arena, clear: bool): unit {
    let usedBytes = self.usedBytes();
    println("[arena] Resetting {usedBytes / kb}KiB");
    self.curAddr* <- (self.basePtr as uword);

    if clear {
      println("mem/set clear {self.basePtr} 0 {usedBytes}");
      mem/set(dst = self.basePtr, value = 0, count = usedBytes);
    }
  }

  fn pushLayout(self: *mut Arena, size: uword, align: uword): Pointer {
    let dataStart = Pointer/alignAddr(self.curAddr, align);
    let newEnd = dataStart + size;
    if newEnd > self.maxAddr {
      crash("Arena is out of space to allocate {size} bytes. newEnd: {newEnd}. maxAddr: {self.maxAddr}")
    };

    self.curAddr* <- newEnd;
    dataStart as Pointer
  }

  fn pushUninit[T](self: *mut Arena): *mut T {
    let dataStart = self.pushLayout(sizeOf[T](), alignOf[T]());
    dataStart as *mut T
  }

  fn push[T](self: *mut Arena, t: T): *mut T {
    let dataStart = self.pushLayout(sizeOf[T](), alignOf[T]());

    let ref: *mut T = dataStart.rw();
    ref <- t;
    ref
  }

  fn pushN[T](self: *mut Arena, ts: View[T]): Buffer[T] {
    let size = ts.buffer.sizeBytes();
    let align = types/alignOf[T]();
    let base = self.pushLayout(size, align);
    let buffer: Buffer[T] = Buffer/fromRawPointerAndCount[T](base, ts.len());
    Buffer/copyFrom(src = ts.buffer, dst = buffer);
    buffer
  }

  fn pushString(self: *mut Arena, s: string): string {
    let data: Buffer[char] = self.pushN(s.view());
    string/wrapBuffer(data)
  }

  fn pushList[T](self: *mut Arena, cap: uword): List[T] {
    List/withCapacityIn(context .CustomArena(self))(cap)
  }

}
