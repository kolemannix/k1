ns bitfield;

// Lets you create bitfields with masks, bindings, and getters/setters. Example usage:
// #meta bitfield/define[u16]("FlagsAuto", [b1("shielded"), b1("cloaked"), b1("damaged"), { name: "sectorId", bits: 5 }, b8("foo")])

fn intWidthForBits(bits: size): size {
  if bits <= 8 8
  else if bits <= 16 16
  else if bits <= 32 32
  else if bits <= 64 64
  else crash("Too many bits: {bits}")
}
fn bn(name: string, bits: size): { name: string, bits: size } { { name, bits } }
fn b1(name: string): { name: string, bits: size } { bn(name, 1) }
fn b8(name: string): { name: string, bits: size } { bn(name, 8) }
fn define[Base](typeName: string, members: View[{ name: string, bits: size }]): string {
  use core/StringBuilder; use meta/CodeWriter;

  let baseTypeId: u64 = types/typeId[Base]();
  let baseSchema = types/typeSchema(baseTypeId);
  let baseName = types/typeName(baseTypeId);
  require baseSchema is .Int(intKind) else { crash("Base should be an int; got {baseName}") };
  let totalBits = intKind.bitWidth();

  // This is just a regular StringBuilder that gets some extra methods since we've
  // brought the meta/CodeWriter ability into scope
  let* code = StringBuilder/new(); // The asterisk means we want a reference (a stack address)

  // This defines a named struct type with one field, which is a common newtype pattern
  code.line("deftype {typeName} = {{ bits: {baseName} }");

  // We crack open a namespace to put some goodies inside
  code.line("ns {typeName} {{");

  // This actually gets captured by the lambda below
  let* bitIndex = 0;

  // Let's analyze each member we were passed, and perform the actual bitfield layouting work once.
  // We'll make a list of an unnamed (anonymous) little struct type for our info we'll need later
  let memberInfo: List[{ 
    // mask: the positioned mask
    mask: usize,
    // typeWidth: the smallest type that can hold these bits; see `intWidthForBits`
    typeWidth: size,
    // invMask: the negation of the mask, but also masked down to typeWidth size (to generate constants that fit)
    invMask: usize,
    // rawValue: the mask shifted to the start, the 'magnitude' of the used bits
    rawValue: usize,
    // offset: the bit pos that the mask starts at; where the value lives; how much to shift
    offset: size,
    // nameCap: the name of the field, capitalized
    nameCap: string
  }] = List/fromMap(members, \member. {
    let bits = member.bits;
    if bitIndex.* + bits > totalBits crash("Too big: {bitIndex.* + bits}");
    let rawValue = u64/bitmaskLow(bits);
    let typeWidth = intWidthForBits(bits);
    let nameCap = member.name.capitalizeAscii();
    let mask = rawValue.shiftLeft(bitIndex.*.as());
    let offset = bitIndex.*;
    let sizeMask = u64/bitmaskLow(typeWidth);
    let invMask = mask.bitNot().bitAnd(sizeMask);

    bitIndex <- bitIndex.* + bits;

    { mask, typeWidth, invMask, rawValue, offset, nameCap }
  });

  // The for loop works on any type that implements Iterable or Iterator
  // The item being iterated over is named `it` if no binding is supplied
  // `itIndex` is also given to us
  for members {
    let info = memberInfo.get(itIndex);
    // Emit globals, or constants, for each field's mask
    code.line("  let {it.name}Mask: {baseName} = {info.mask};");
  };

  code.line("  let zero: {typeName} = {{ bits: 0 };");

  // Now let's do a getter and setter for each bitfield. If the width is 1,
  // we'll use bool since that's what the people likely want. Note that we could configure
  // any of this behavior because this is just a regular function
  for members {
    let info = memberInfo.get(itIndex);
    let nameCap = info.nameCap;
    let isBool = it.bits == 1;
    let fieldType = if isBool "bool" else "u{info.typeWidth}";

    // Getter
    code.line("  fn get{nameCap}(self: {typeName}): {fieldType} {{");

    code.line("    let bits: {baseName} = self.bits;");
    code.line("    let shifted: {baseName} = bits.shiftRight({info.offset});");
    code.line("    let cleared: {baseName} = shifted.bitAnd({info.rawValue});");
    if isBool {
      code.line("    cleared == 1")
    } else {
      code.line("    cleared.as[{fieldType}]");
    };

    code.line("  }"); // End Getter

    // Setter
    code.line("  fn set{nameCap}(self: {typeName}, value: {fieldType}): {typeName} {{");
    if isBool {
      code.line("    let maskedValue = (value.as_u8());")
    } else {
      code.line("    let maskedValue: {baseName} = value.bitAnd({info.rawValue});")
    };
    let clearMask = info.invMask;
    code.line("    let clearedBits: {baseName} = self.bits.bitAnd({clearMask});");
    code.line("    let insertedBits: {baseName} = clearedBits.bitOr(maskedValue.shiftLeft({info.offset}));");
    code.line("    {{ bits: insertedBits }");
    code.line("  }"); // End setter
  };

  code.line("}"); // End ns

  let* printBody = StringBuilder/new();
  for members {
    let info = memberInfo.get(itIndex);
    let getName = "get{info.nameCap}";
    let last = itIndex + 1 == members.len();
    let sep = if last "" else ",";
    printBody.line(`    w.writeString("{it.name}={{self.{getName}()}{sep}");`);
  };
  code.implPrint(typeName, printBody.build(), indent = 0);

  code.build()
}
