use core/StringBuilder
use meta/CodeWriter

fn fmt[Fmt: static string, Args, W: Writer](w: W, fmtString: Fmt, args: Args) {
  #meta(fmtString) {
    let* code = StringBuilder/new();
    let argsTypeId = types/typeId[Args]();
    let schema = types/typeSchema(argsTypeId);
    // This naive splitting doesn't work; we need to walk the format string
    // emitting "string parts" or "arg specifiers"
    // Then iterate that structure to produce the runtime
    // code, which will need the baked string parts
    let parts = fmtString.splitByChar('?');

    code.var("parts", parts.asView());
    switch schema {
      .String -> {
        if parts.len != 1 {
          crash("Got 1 format argument (a string) but format string has {parts.len}")
        };
        //meta/emitLine("its a string baby");
        code.line("parts.get(0).printTo(w);");
        code.line("w.writeString(args);");
      },
      .Struct({fields}) -> {
        if parts.len != fields.len() {
          crash("Mismatching format arg count")
        };

        for field in fields {
          code.line("let f{itIndex} = args.{field.name};")
        };

        for part in parts {
          code.line("parts.get({itIndex}).printTo(w);");
          code.line("f{itIndex}.printTo(w);");
        };

      },
      _ -> crash("Unsupported format arguments: {types/getTypeName[Args]}")
    };
    code.build()
  }
}

// TODO: need to flesh this out more with format specifiers
//           and other things
fn fmtString[Fmt: static string, Args](fmtString: Fmt, args: Args): string {
  let* result = StringBuilder/new();
  fmt(result, fmtString, args);
  result.build()
}

fn test() {
  let s1 = fmtString("My value is: ? ?", {a: 42, b: true});
  //let s1 = sprintf(args.get(1), {a: 42, b: true});
  assertEquals(s1, "My value is: 42 true");
  let s3 = fmtString("My values are: ? and ?", {a: "asdf", b: true});
  assertEquals(s3, "My values are: asdf and true");

  let s4 = fmtString("My string is ?", "Hello, World!");
  assertEquals(s4, "My string is Hello, World!");

  {}
}

// I think it compiles to a struct literal; { fmtStr: string, arg1: <t1>, arg2: <t2>, etc, etc, etc }

// The current string interpolation is lacking some elegance
// because it couples 2 things: specifying a list of writables, either strings or expressions,
// writing those to a Writer, and allocating a Writer.

// for example, you could imagine supplying your own writer to skip the intermediate string
// if you know you're going to stdout:
//fmt(stdout, "{1} {2} {} {}", [3, 4]);
// But this would require some sort of macro that I do not have
// I could also do just a magic builtin called `fmt` that is compiler-implemented
// Takes a Writer, a format string, and N args. But we're not that far from
// being able to do this in comptime userland. So I'm just going to wait
// until I have a final macro system, then move interpolation there.
// This way, it can be de-coupled from string construction if desired, but 
// also coupled if you do want a string for convenience

//deftype Expr = either FmtString(Parts), Other(string)
//macro fmt(writer: Expr, s: Expr, args: View[Expr]) {
//fn fmt[W: Writer, S: static FmtString, Args](writer: W, fmtString: S, args: Args) {
//  let* sb = StringBuilder/new();
//  let argsCount = 
//  for p in s.parts { 
//    switch p {
//      .String(s) -> { 
//        // format("?.writeString(?)");
//        writer.printTo(sb); sb.writeString(".writeString("); s.printTo(sb); sb.writeString(")")  
//      },
//      .Expr(e) -> { e.printTo(sb); sb.writeString(".printTo("); writer.printTo(sb); sb.writeString(")") }
//    }
//  }
//}
