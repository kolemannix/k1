impl Show for { rank: int, payload: string } {
  fn show(self: Self): string {
    let rank = self.rank;
    let payload = self.payload;
    "Payload: \{payload} (rank=\{rank})"
  }
}

impl Comparable for { rank: int, payload: string } {
  fn compare(self: Self, other: Self): Ordering {
    self.rank.compare(other.rank)
  }
}

impl Equals for { rank: int, payload: string } {
  fn equals(self: Self, other: Self): bool {
    self.rank == other.rank and self.payload == other.payload
  }
}

impl Equals for Array[{ rank: int, payload: string }] {
  fn equals(self: Self, other: Self): bool {
    if self.len != other.len {
      false
    } else {
      let mut i: u64 = 0;
      while i < self.len {
        if self.get(i) != other.get(i) {
          return(false);
        };
        i = i + 1;
      };
      true
    }
  }
}

fn testSortInt(input: Array[int], expected: Array[int]): unit {
  let sorted = input.sorted();
  assert(sorted == expected);
}

fn testSortOther(input: Array[{ rank: int, payload: string }], expected: Array[{ rank: int, payload: string }]): unit {
  let sorted = input.sorted();
  assert(sorted == expected);
}

fn main(): int {
  testSortInt([], []);
  testSortInt([0], [0]);
  testSortInt([5,4], [4,5]);
  testSortInt([5,3,1], [1,3,5]);
  testSortOther([
    { rank: 1, payload: "third" },
    { rank: 0, payload: "first" },
    { rank: 0, payload: "second" }
  ], [
    { rank: 0, payload: "first" },
    { rank: 0, payload: "second" },
    { rank: 1, payload: "third" }
  ]);
  0
}
