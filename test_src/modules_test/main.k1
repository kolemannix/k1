let MODULE_INFO: core/k1/ModuleManifest = {
  kind: .Executable,
  deps: [],
  multithreading: false,
  libs: ["foo"]
};

//fn deriveStructPrint[S](): string {
//  let schema = types/getTypeSchema[S]();
//  require schema is .Struct({ fields }) else { crash("") };
//  let* code = StringBuilder/new();
//  code.putString("{{ ");
//  for fields {
//    code.putString()
//  }
//}

ns foo {

  deftype VerySmall = { x: u8 }
  impl Print for VerySmall { fn printTo[W: Writer](self: VerySmall, w: W): unit { w.writeString("{ {self.x} }") } }
  impl Equals for VerySmall { fn equals(self: VerySmall, other: VerySmall): bool { self.x == other.x } }
  extern("foo", "very_small") fn very_small(x: VerySmall, y: VerySmall): VerySmall

  deftype Small = { r: u8, g: u8, b: u8, a: u8 }
  extern("foo", "small")      fn small(x: Small, y: Small): Small

  deftype Medium = { a: u64, b: u64 }
  extern("foo", "medium")     fn medium(a: Medium, b: Medium): Medium

  deftype MixedClassMedium = { f1: f32, f2: f32, i3: Array[i16, 4] }

  deftype Large = { med1: Medium, med2: Medium }
  extern("foo", "large")      fn large(a: Large, b: Large): Large


}

fn testAll(): unit {
  assertEquals(
    foo/very_small({ x: 10 }, { x: 20 }),
    { x: 30 }
  );
  let mediumResult = foo/medium({ a: 10, b: 100 }, { a: 1, b: 20 });
  assertEquals(mediumResult.a, 11);
  assertEquals(mediumResult.b, 120);

  let largeResult = foo/large(
    { med1: { a: 1, b: 2 }, med2: { a: 3, b: 4 } },
    { med1: { a: 10, b: 20 }, med2: { a: 30, b: 40 } }
  );
  assertEquals(largeResult.med1.a, 11);
  assertEquals(largeResult.med1.b, 22);
  assertEquals(largeResult.med2.a, 33);
  assertEquals(largeResult.med2.b, 44);
}

fn main(): i32 {
  testAll();
  #static testAll();
  0
}
