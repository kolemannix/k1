ns match_exhaust;

fn matchBool(b: bool): string {
  switch b {
    false -> identity("false"),
    true -> identity("true")
  }
}

deftype TriState = either Yes, No, Failure({ reason: string })
fn matchTristateOpt(t: ?TriState): string {
  switch t {
    .Some(.Yes) -> "yes",
    .Some(.No) -> "no",
    .Some(.Failure(s)) -> "failure: {s.reason}",
    .None -> "none"
  }
}

fn failedWithBaz(t: TriState): bool {
  switch t {
    .Yes -> false,
    .No -> false,
    .Failure(s) -> s.reason == "baz"
  }
}

fn matchOptBool(b: ?bool): string {
  switch b {
    .None -> identity("None"),
    .Some(false) -> identity("false"),
    .Some(true) -> identity("true")
  }
}

fn bothTrue(bb: { a: bool, b: bool }): bool {
  switch bb {
    { a: false, b: false } -> false,
    { a: false, b: true } -> false,
    { a: true, b: false } -> false,
    { a: true, b: true } -> true
  }
}

fn main(): i32 {
  switch 'x' {
    'x' -> {},
    a -> {}
  };

  assertEquals(matchBool(false), "false");
  assertEquals(matchOptBool(.Some(false)), "false");
  assertEquals(matchOptBool(.None), "None");

  let yes: TriState = .Yes;
  assertEquals(matchTristateOpt(.Some(yes)), "yes");
  assertEquals(matchTristateOpt(.Some(.Yes)), "yes");
  assertEquals(matchTristateOpt(.Some(.Failure({ reason: "because" }))), "failure: because");

  assert(not bothTrue({ a: true, b: false }));
  assert(bothTrue({ a: true, b: true }));

  assert(failedWithBaz(.Failure({ reason: "baz" })));
  assert(not failedWithBaz(.No));

  switch some(42) {
    .Some(x) if x == 42 -> {},
    _ -> assert(false),
  };

  0
}
