ns generic_struct;

deftype Box[T] = { value: T }
deftype AuPair[T, U] = { t: ?T, u: ?U }
ns AuPair {
  fn t[T, U](self: AuPair[T, U]): ?T {
    self.t
  }
}


fn unboxIt[T](b: Box[Box[Box[T]]]): T {
  b.value.value.value
}

fn takesPolyAuPair[C, D](_x: AuPair[C, D]) { {} }

deftype ConstrainedBox[A, B: Try[T = A, E = empty]] = { inner: B }
fn testConstraints() {
  // Should typecheck just fine since the constraint is satisfied
  let x: ConstrainedBox[int, ?int] = { inner: some(4) };
  assertEquals(types/typeId[typeOf(x).A](), types/typeId[int]());
  assertEquals(
    testCompile({ inner: some(4) }: ConstrainedBox[int, ?bool]),
    .Some("Provided type B := Opt[bool] does implement required ability Try, but the implementation parameter T is wrong: Expected type was i64 but the actual implementation uses bool")
  );
  {}
}

fn test() {
  let b: Box[int] = { value: 0 };
  b.value;
  let c: Box[bool] = { value: true };
  let c2: Box[bool] = { value: false };
  let c3: Box[?bool] = { value: .Some(false) };
  let c4: Box[*bool] = { value: core/mem/new(false) };
  assertEquals(b.value, 0);
  assertEquals(c.value, true);
  assertEquals(c2.value, false);
  assertEquals(c3.value.!, false);
  assertEquals(c4.value.*, false);

  let p: AuPair[int, bool] = { t: some(0), u: some(true) };
  assert(p.t.! == 0);
  assert(p.u.! == true);
  assert(p.t[int, bool]().! == 0);
  assert(p.t().! == 0);

  let nested: Box[Box[Box[int]]] = { value: { value: { value: 42 } } };
  assert(unboxIt(nested) == 42);

  takesPolyAuPair({ t: some(42), u: Opt.Some(true) });
  takesPolyAuPair({ t: some(42), u: .Some(true) });
  takesPolyAuPair({ t: some(42), u: some(true) });

  takesPolyAuPair[int, _]({ t: some(42), u: some(true) });
  takesPolyAuPair[_, bool]({ t: some(42), u: some(true) });
  takesPolyAuPair[_, _]({ t: some(42), u: some(true) });

  assert(
    testCompile(takesPolyAuPair[ptr, _]({ t: some(42), u: some(true) }))
    is .Some(_)
  );
  assert(
    testCompile(takesPolyAuPair[_, ptr]({ t: some(42), u: some(true) }))
    is .Some(_)
  );

  testConstraints();

  {}
}
