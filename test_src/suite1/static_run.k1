ns static_run;
let INT_VIEW: View[int] = [1,2,3,4,5];

let i2: 12 = { 3 * 4 };
let i3: 12 = #static { 3 * 4 };
let i4: 12 = #static 3 * 4;

let s1: string = #static {
  let a = "asd";
  a.concat("f")
};
let s2: "asdf" = #static {
  let a = "asd";
  a.concat("f")
};

fn staticsAndCoercion(): i32 {
   let _i: "a" = #static "a";
   let _i2: string = #static "a";
   let _i3: "a" = "a";
   0
}

fn getPoint(): { x: u8, y: u32, z: i64 } {
  { x: 1, y: 300, z: -222 }
}
fn test() {
  // String creation (special case)
  #static "Hello, Static";

  // Struct creation
  let point = #static {
    ({ x: 1, y: 2 })
  };

  // Type assertions
  (point.x: 1);
  (point.y: 2);
  // Value assertions
  assertEquals(point.x.fromStatic(), 1);
  assertEquals(point.y.fromStatic(), 2);

  // Scalars
  assert(#static true);
  assert(not (#static false));
  assert(not (#static true == false));
  assert(#static {} == {});
  assert(#static 'a' == 'a');
  assert(not #static 'A' == 'a');
  assert(not #static 123 == -123);
  assert(not #static 123.0 == 3.14);

  // Return struct
  assertEquals[u8](#static getPoint().x, 1);
  assertEquals[u32](#static getPoint().y, 300);
  assertEquals[i64](#static getPoint().z, -222);

  // Variable assign
  let goodbye: "Goodbye, World!" = #static {
    let msg = "Hello, World";
    msg := "Goodbye, World!";
    msg
  };
  assertEquals[string](goodbye, "Goodbye, World!");

  let letAssign = #static {
    let i = 22;
    i := 10;
    i
  };
  assertEquals[int](letAssign, 10);

  let padded = #static {
    let padded = { a: 1: u8, b: 2: u8, c: 3: u8, d: 4: u64, e: 5 };
    padded
  };
  (padded.a: 1u8);
  (padded.b: 2u8);
  (padded.c: 3u8);
  (padded.d: 4u64);
  (padded.e: 5i64);

  let letRef = #static {
    let* i = 10;

    //assert(i.* == 10);
    i <- core/identity(i.*);
    i.*
  };
  assertEquals[int](letRef, 10);

  assertEquals(core/k1/IS_STATIC, false);
  #static assert(core/k1/IS_STATIC);

  let enum1 = #static {
    let x = some(42);
    let y = if x is .Some(x) x else crash("");
    y
  };
  assertEquals[int](enum1, 42);

  let fieldPtrTest: int = #static {
    let* x = 21;
    let s = { ptr: x };
    s.ptr.*
  };
  assertEquals(fieldPtrTest, 21);


  let ptrInStructs = #static {
    let* b: *u8 = 10;
    let* f = { asdf: b };
    f.asdf.*
  };
  assertEquals[u8](ptrInStructs, 10);

  //// Loops
  #if false assertEquals(#static {
    let i = 0;
    loop {
      if i >= 5 { break() };
      i := i + 1
    };
    i
  }, 5);

  #if false assertEquals(#static {
    let i = 0;
    while i < 5 { i := i + 1 };
    i
  }, 5);

  #static {
    let* l = List/withCapacity[empty](0);
    l.len
  };

  // lists
  let listLast = #static {
    let inced = [1,2,3,4,5].map(\it. it+1);
    inced.last()
  };
  assertEquals[?int](listLast, some(6));

  assertEquals[int](#static loop {
    switch 42 {
      _ -> break(100)
    }
  }, 100);

  // StringBuilder

  assertEquals[string](#static {
    let* sb = core/StringBuilder/new();
    sb.writeString("Hello");
    sb.build()
  }, "Hello");

  assertEquals[?string](
    testCompile( #static assert(false) ).map(\(s) s.take(38)),
    some("Static execution exited with code: 111")
  );

  // Call order
  #static bar(2);

  // View
  let view: View[int] = #static {
    let xs = [1,2,3,4,5];
    xs.asView()
  };
  assertEquals(view, [1,2,3,4,5]);
  #static {
    let* l = List/wrapBuffer(Buffer/copyFromView(INT_VIEW));
    l.push(9);
    assertEquals(l.len, 6);
    assertEquals(l.last(), some(9));
  };


  // Simple lambda
  assertEquals[int](#static {
    let lam = \(x: int) x * 2;
    lam(1)
  }, 2);

  // View of views!
  let vov: View[View[int]] = #static [[1,2,3], [4,5,6]];
  assertEquals(vov.len(), 2);
  assertEquals(vov.get(0).get(0), 1);
  assertEquals(vov.get(0).get(1), 2);
  assertEquals(vov.get(0).get(2), 3);
  assertEquals(vov.get(1).get(0), 4);
  assertEquals(vov.get(1).get(1), 5);
  assertEquals(vov.get(1).get(2), 6);


  let point = #static { x: 1, y: (#static 2): int };
  assertEquals(point.fromStatic().x, 1);

  {}
}

fn getOne(): int { 1 }
fn getThree(): int { getOne() + 2 }

fn foo(n: int) {
  if n == 0 return()
  else bar(n - 1)
}

fn bar(n: int) {
  if n == 0 return()
  else foo(n - 1)
}

