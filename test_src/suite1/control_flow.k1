ns control_flow;

fn ifBasic(): int {
  let cond: bool = false;
  let result: int = if cond 42 else 1337;
  assert(result == 1337);
  0
}

fn ifNoElse(): int {
  // Gets empty type
  let x = 0;
  let expr: {} = if true {
    x := 42;
  };
  assert(x == 42);
  assert(expr == {});

  // Even if one branch is 'never'
  let _expr: {} = if false {
    crash("never happens");
  };
  0
}

fn returnSimple(): bool {
  return(true)
}

fn rand(): bool { true }
fn returnFromIf(): int {
  let _x: {} = if rand() {
    return(1)
  };

  0
}

fn loopBreak() {
  // Break with scalar
  let x: int = loop {
    let _inner: int = if true {
      break(3)
    } else 4
    
  };
  assertEquals(x, 3);

  // Break with aggregate
  let y: string = loop {
    break("asdf")
  };
  assertEquals(y, "asdf")
}

fn loopNested() {
  let result = loop {
    break(loop { break(10) })
  };
  assertEquals(result, 10)
}

fn loopFalse() {
  let x = loop {
    break(3);
  };
  assert(x == 3)
}

fn doCrash(): bool {
  crash("should not run");
}

fn test() {

  ifBasic();
  ifNoElse();
  assert(returnSimple());
  assert(returnFromIf() == 1);

  // Short-circuiting is guaranteed
  if (false and doCrash()) {};

  loopBreak();
  loopNested();
  loopFalse();
}
