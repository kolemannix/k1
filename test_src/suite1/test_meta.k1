// If you'd like to write some code that you need available
// for metaprogramming, you can place it in your module's `pre`
// namespace. The pre namespace is not different than any other
// namespace, except that it gets fully compiled before the rest
// of its enclosing module.

// It's effectively the same thing as defining a 
// separate module, but more convenient

// Usage can even appear above the pre ns
#meta pre/makePoint("MyMetaPoint")

ns pre {
  let pi: f32 = 3.14;
  fn makePoint(name: string): string {
    "deftype {name} = {{ x: i32, y: i32 }";
  }
}

ns test_meta;

use core/StringBuilder
use core/meta/CodeWriter

fn simpleIncrement(): i32 {
  let x = 10;
  #meta {
    let* code = StringBuilder/new();
    for core/IntRange/upTo(5) {
      code.line("x := x + 1;");
    };
    code.build()
  };
  assertEquals(x, 15);

  0
}

use core/Writer
use types/TypeSchema
use types/typeSchema

fn _writeJsonFromSchema(code: *mut StringBuilder, name: string, typeId: u64): unit {
  switch typeSchema(typeId) {
    .Struct(s) -> {
      code.line("w.writeChar('{{');");
      for f in s.fields {

        let fieldLetName = `_{name}{f.name}`;

        code.writeString(
`let {fieldLetName} = {name}.{f.name};
w.writeString("\"{f.name}\":");
`
       ); //" fix quote

        _writeJsonFromSchema(code, fieldLetName, f.typeId);
        let last = itIndex == s.fields.len() - 1;
        if not last {
          code.line(`w.writeString(",");`);
        }
      };
      code.line(`w.writeChar('}');`);
    },
    .Unit -> code.line(`w.writeString(\`"unit"\`);`),
    .Bool -> {
      code.line(`w.writeString(if {name} "true": string else "false");`)
    },
    .Int(_) -> code.line(`{name}.printTo(w);`),
    .Either(_) -> {
      let tName = types/typeName(typeId);
      crash("Cannot yet create a JSON writer for either: {tName}")
    },
    _ -> {
      code.line(`w.writeString(\`"other"\`)`)
    }
  };
}

fn writeJson[T, W: Writer](context w: W)(t: T): unit {
  #meta {
    let typeId = types/typeId[T]();
    let* code = StringBuilder/new();
    _writeJsonFromSchema(code, "t", typeId);
    code.build()
  }
}

fn toJson[T](t: T): string {
  let* w = List/empty[char]();
  writeJson(context w)(t);
  let s = string/wrapList(w);
  s
}

fn testToJson(): unit {
  assertEquals(toJson(true), "true");
  let json1 = toJson({ x: 1, y: 2, z: (), d: false });
  assertEquals(json1, `{{"x":1,"y":2,"z":"unit","d":false}`);

  ()
}


fn test(): unit {
  simpleIncrement();
  testToJson();

  let x: MyMetaPoint = { x: 0, y: 42 };
  pre/pi;
  
  ()
}
