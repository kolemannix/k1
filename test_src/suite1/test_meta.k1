ns test_meta;

use core/meta/emitLine
use core/meta/emit
use core/StringBuilder

fn simpleIncrement(): i32 {
  let mut x = 10;
  #meta {
    // nocommit(2): Provide a meta/CodeBuilder
    let code = core/StringBuilder/new();
    for core/IntRange/upTo(5) do {
      code.putString("x = x + 1;\n");
    };
    code.build()
  };
  assertEquals(x, 15);

  0
}

use core/Writer
use types/TypeSchema
use types/typeSchema

fn _writeJsonFromSchema(context code: StringBuilder)(name: string, typeId: u64): unit {
  switch typeSchema(typeId) {
    .Struct(s) -> {
      emitLine(context code)(#code w.writeChar('{'));
      for f in s.fields do {

        let fieldLetName = `_{name}{f.name}`;

        code.putString(
         `let {fieldLetName} = {name}.{f.name};
          w.writeString("\"{f.name}\":");`
       ); //" fix quote

        _writeJsonFromSchema(fieldLetName, f.typeId);
        let last = itIndex == s.fields.len() - 1;
        if not last {
          emitLine(context code)(#code w.writeString(","));
        }
      };
      emitLine(context code)(#code w.writeChar('}'));
    },
    .Unit -> emitLine(context code)(#code w.writeString(`"unit"`)),
    .Bool -> {
      emitLine(context code)(`w.writeString(if {name} "true" else "false")`)
    },
    .Word(_) or .Int(_) -> emitLine(context code)(`{name}.printTo(w)`),
    .Either(_) -> {
      let tName = types/typeName(typeId);
      crash("Cannot yet create a JSON writer for either: {tName}")
    },
    _ -> {
      emitLine(context code)(#code w.writeString(`"other"`))
    }
  };
}

fn writeJson[T, W: Writer](context w: W)(t: T): unit {
  #meta {
    let typeId = types/typeId[T]();
    let context code = core/StringBuilder/new();
    _writeJsonFromSchema("t", typeId);
    code.build()
  }
}

fn toJson[T](t: T): string {
  let* mut w = List/empty[char]();
  writeJson(context w)(t);
  let s = string/wrapList(w);
  s
}

fn testToJson(): unit {
  assertEquals(toJson(true), "true");
  let json1 = toJson({ x: 1, y: 2, z: (), d: false });
  assertEquals(json1, `{{"x":1,"y":2,"z":"unit","d":false}`);

  ()
}


fn test(): unit {
  simpleIncrement();
  testToJson()
}
