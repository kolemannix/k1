// If you'd like to write some code that you need available
// for metaprogramming, you can place it in your module's `meta`
// namespace. The meta namespace is not different than any other
// namespace, except that it gets fully compiled before the rest
// of its enclosing module.

// It's effectively the same thing as defining a 
// separate module called, but more convenient

// Can even appear above the meta ns
#meta meta/makePoint("MyMetaPoint")
ns meta {
  let pi: f32 = 3.14;
  fn makePoint(name: string): string {
    "deftype {name} = {{ x: i32, y: i32 }";
  }
}

ns test_meta;

use core/meta/CodeBuilder

fn simpleIncrement(): i32 {
  let mut x = 10;
  #meta {
    let code = CodeBuilder/new();
    for core/IntRange/upTo(5) do {
      code.line("x = x + 1;");
    };
    code.build()
  };
  assertEquals(x, 15);

  0
}

use core/Writer
use types/TypeSchema
use types/typeSchema

fn _writeJsonFromSchema(code: CodeBuilder, name: string, typeId: u64): unit {
  switch typeSchema(typeId) {
    .Struct(s) -> {
      code.line("w.writeChar('{{');");
      for f in s.fields do {

        let fieldLetName = `_{name}{f.name}`;

        code.string(
         `let {fieldLetName} = {name}.{f.name};
          w.writeString("\"{f.name}\":");`
       ); //" fix quote

        _writeJsonFromSchema(code, fieldLetName, f.typeId);
        let last = itIndex == s.fields.len() - 1;
        if not last {
          code.line(`w.writeString(",");`);
        }
      };
      code.line(`w.writeChar('}');`);
    },
    .Unit -> code.line(`w.writeString(\`"unit"\`);`),
    .Bool -> {
      code.line(`w.writeString(if {name} "true" else "false");`)
    },
    .Word(_) or .Int(_) -> code.line(`{name}.printTo(w);`),
    .Either(_) -> {
      let tName = types/typeName(typeId);
      crash("Cannot yet create a JSON writer for either: {tName}")
    },
    _ -> {
      code.line(`w.writeString(\`"other"\`)`)
    }
  };
}

fn writeJson[T, W: Writer](context w: W)(t: T): unit {
  #meta {
    let typeId = types/typeId[T]();
    let code = CodeBuilder/new();
    _writeJsonFromSchema(code, "t", typeId);
    code.build()
  }
}

fn toJson[T](t: T): string {
  let* mut w = List/empty[char]();
  writeJson(context w)(t);
  let s = string/wrapList(w);
  s
}

fn testToJson(): unit {
  assertEquals(toJson(true), "true");
  let json1 = toJson({ x: 1, y: 2, z: (), d: false });
  assertEquals(json1, `{{"x":1,"y":2,"z":"unit","d":false}`);

  ()
}


fn test(): unit {
  simpleIncrement();
  testToJson();

  let x: MyMetaPoint = { x: 0, y: 42 };
  meta/pi;
  
  ()
}
