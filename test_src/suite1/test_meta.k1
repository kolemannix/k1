ns test_meta;

use core/meta/CodeBuilder

fn simpleIncrement(): i32 {
  let mut x = 10;
  #meta {
    let code = CodeBuilder/new();
    for core/IntRange/upTo(5) do {
      code.line("x = x + 1;");
    };
    code.build()
  };
  assertEquals(x, 15);

  0
}

use core/Writer
use types/TypeSchema
use types/typeSchema

fn _writeJsonFromSchema(code: CodeBuilder, name: string, typeId: u64): unit {
  switch typeSchema(typeId) {
    .Struct(s) -> {
      code.line("w.writeChar('{{');");
      for f in s.fields do {

        let fieldLetName = `_{name}{f.name}`;

        code.string(
         `let {fieldLetName} = {name}.{f.name};
          w.writeString("\"{f.name}\":");`
       ); //" fix quote

        _writeJsonFromSchema(code, fieldLetName, f.typeId);
        let last = itIndex == s.fields.len() - 1;
        if not last {
          code.line(`w.writeString(",");`);
        }
      };
      code.line(`w.writeChar('}');`);
    },
    .Unit -> code.line(`w.writeString(\`"unit"\`);`),
    .Bool -> {
      code.line(`w.writeString(if {name} "true" else "false");`)
    },
    .Word(_) or .Int(_) -> code.line(`{name}.printTo(w);`),
    .Either(_) -> {
      let tName = types/typeName(typeId);
      crash("Cannot yet create a JSON writer for either: {tName}")
    },
    _ -> {
      code.line(`w.writeString(\`"other"\`)`)
    }
  };
}

fn writeJson[T, W: Writer](context w: W)(t: T): unit {
  #meta {
    let typeId = types/typeId[T]();
    let code = CodeBuilder/new();
    _writeJsonFromSchema(code, "t", typeId);
    code.build()
  }
}

fn toJson[T](t: T): string {
  let* mut w = List/empty[char]();
  writeJson(context w)(t);
  let s = string/wrapList(w);
  s
}

fn testToJson(): unit {
  assertEquals(toJson(true), "true");
  let json1 = toJson({ x: 1, y: 2, z: (), d: false });
  assertEquals(json1, `{{"x":1,"y":2,"z":"unit","d":false}`);

  ()
}


fn test(): unit {
  simpleIncrement();
  testToJson()
}
