ns lambdas {

fn map[T, U](a: List[T], f: some \T -> U): List[U] {
  let* us = List/withCapacity[U](a.len);
  for i in a do { us.push[U](f(i)) };
  us.*
}

//fn map(a: List[int], f: (int -> int)*); List[int]
//fn map(a: List[int], f: dyn[int -> int]): List[int]
//fn map(a: List[int], f: unique[int -> int]): List[int]
//-> Codegened to:
//fn map(a: List[int], f: { env struct }*): List[int]



// fn flatMap[T, U](a: List[T], f: some \T -> List[U]): List[U] {
//   let* us = List/withCapacity[U](a.len);
//   for i in a do { us.push[U](f(i)) };
//   us.*
// }

// Todo: this performs dynamic dispatch, always
// We could instead specialize the function on the closure type
// and get static dispatch
fn filter[T](a: List[T], f: some \T -> bool): List[T] {
  let* keep = List/empty[T]();
  for i in a do { if f(i) keep.push(i) };
  keep
}

fn staticAddOne(x: int): int { x + 1 }

fn captures(): unit {
  let closedOver: int = 3;

  let add = \(x: int) {
    let addOne = \(y: int) y + 1;
    addOne(x) + closedOver + addOne(closedOver) + (if closedOver == 3 1 else 0);
  };

  assertEquals(add(3), 12);
}

fn captureMut(): unit {
  let* counter = 3;

  let inc = \(x: int) {
    counter <- counter.* + 1;
  };

  inc(0);
  inc(0);
  inc(0);

  assert(counter.* == 6);
}

fn closureReturn(): unit {
  let getThree = \(-> int) { return(3) };
  let nullary = \() 4;
  assert(getThree() == 3);
  assert(nullary() == 4);
}

fn lam1(i: int, f: some \int -> int): int {
  f(i)
}

fn lam2(i: int, f: some \int -> int, g: some \int -> int): int {
  f(i) + g(i)
}

// fn genLam[T](t: T, f: )

fn test(): unit {

  let lam1Result = lam1(5, staticAddOne);
  assertEquals(lam1Result, 6);

  let* c1 = { x: 3 };
  let c2 = 2;

  let withClosures = lam2(5, \(x) x + 1 + c1.x, \(x) x + 2 + c2);
  assertEquals(withClosures, (5 + 1 + 3) + (5 + 2 + 2));

  let staticAddOneVar = staticAddOne;
  let staticResult = lam2(5, staticAddOne, staticAddOneVar);
  assertEquals(staticResult, 6 + 6);

  let result = ([1,2,3,5,6,7,8] | map(\(x: int) x + 1)) | filter(\(x: int) x % 2 == 0);
  assert(result == [2, 4, 6, 8]);

  // captures();
  // captureMut();
  // closureReturn();
  ()
}

}

fn main(): int {
  lambdas/test();
  0
}
