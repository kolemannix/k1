ns lambdas {

fn map[T, U](a: List[T], f: some \T -> U): List[U] {
  let* us = List/withCapacity[U](a.len);
  for i in a do { us.push[U](f(i)) };
  us.*
}

//fn map(a: List[int], f: (int -> int)*); List[int]
//fn map(a: List[int], f: dyn[int -> int]): List[int]
//fn map(a: List[int], f: unique[int -> int]): List[int]
//-> Codegened to:
//fn map(a: List[int], f: { env struct }*): List[int]



// fn flatMap[T, U](a: List[T], f: some \T -> List[U]): List[U] {
//   let* us = List/withCapacity[U](a.len);
//   for i in a do { us.push[U](f(i)) };
//   us.*
// }

// Todo: this performs dynamic dispatch, always
// We could instead specialize the function on the closure type
// and get static dispatch
fn filter[T](a: List[T], f: some \T -> bool): List[T] {
  let* keep = List/empty[T]();
  for i in a do { if f(i) keep.push(i) };
  keep
}

fn staticAddOne(x: int): int { x + 1 }
fn staticAddTwo(x: int): int { x + 2 }

fn captures(): unit {
  let closedOver: int = 3;

  let add = \(x: int) {
    let addOne = \(y: int) y + 1;
    addOne(x) + closedOver + addOne(closedOver) + (if closedOver == 3 1 else 0);
  };

  assertEquals(add(3), 12);
}

fn captureMut(): unit {
  let* counter = 3;

  let inc = \(x: int) {
    counter <- counter.* + 1;
  };

  inc(0);
  inc(0);
  inc(0);

  assert(counter.* == 6);
}

fn closureReturn(): unit {
  let getThree = \(-> int) { return(3) };
  let nullary = \() 4;
  assert(getThree() == 3);
  assert(nullary() == 4);
}

fn someFnParam1(i: int, f: some \int -> int): int {
  f(i)
}

fn someFnParam2(i: int, f: some \int -> int, g: some \int -> int): int {
  f(i) + g(i)
}

fn someFnParamGen[T](t: T, f: some \T -> T, g: some \T -> T?): T? {
  t | f | g
}

// TODO: fix that syntax allow \() -> unit
// TODO: there's no way to go from lambda -> lambda object aka dyn[lambda] currently
fn runThings(thunks: List[dyn[\-> unit]]): unit {
  for thunk in thunks do { thunk() }
}

fn test(): unit {

  assert(staticAddOne.toRef() as Pointer == staticAddOne.toRef() as Pointer);

  assert(staticAddOne.toRef() as Pointer != staticAddTwo.toRef() as Pointer);

  let staticAddOneVar = staticAddOne.toRef();
  let staticResult = someFnParam2(5, staticAddOne.toRef(), staticAddOneVar);
  assertEquals(staticResult, 6 + 6);

  let lam1ResultPtr = someFnParam1(5, staticAddOne.toRef());
  assertEquals(lam1ResultPtr, 6);

  let lam1ResultDyn = someFnParam1(5, staticAddOne.toDyn());
  assertEquals(lam1ResultDyn, 6);

  let* c1 = { x: 3 };
  let c2 = 2;

  let withClosures = someFnParam2(5, \(x) x + 1 + c1.x, \(x) x + 2 + c2);
  assertEquals(withClosures, (5 + 1 + 3) + (5 + 2 + 2));

  let withGenerics = someFnParamGen(true, \(b) not b, \(b) some(b));
  assert(withGenerics == some(false));

  let result = ([1,2,3,5,6,7,8] | map(\(x: int) x + 1)) | filter(\(x: int) x % 2 == 0);
  assert(result == [2, 4, 6, 8]);

  let* counter = 0;
  let thunks: List[dyn[\ -> unit]] = [
    \() { counter <- counter.* + 1 },
    \() { counter <- counter.* + 1 },
    \() { counter <- counter.* + 1 },
  ];

  runThings(thunks);

  captures();
  captureMut();
  closureReturn();
  ()
}

}

fn main(): int {
  lambdas/test();
  0
}
