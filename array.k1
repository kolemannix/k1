fn listToArray[N: static uword, T](list: List[T], count: N): Array[N x T]* {
  let countVal = count.fromStatic();
  assertEquals(list.len, countVal);
  let base: Pointer = list.toBuffer().cloned().dataPointer();
  base as Array[N x T]*
}

deftype Thing = {
  data: Array[1024 x u8],
  data2: Array[1024 x u64],
}

fn testLiterals(): unit {
  let* array: Array[3 x bool]* = [false, true, true];
  let buffer: Buffer[bool] = [false, true, true];
  let list: List[bool] = [false, true, true];
  assertEquals(array.toBuffer(), buffer);
  assertEquals(list.toBuffer(), buffer);
}

fn testFilled(): unit {
  let context alloc: mem/AllocMode = mem/AllocMode/TEMP;
  let buffer: Buffer[u8] = Buffer/filledIn(size = 64, value = 3);
  let array: Array[64 x u8]* = Array/filledIn(3, 64);
  let list: List[u8] = List/filledIn(size = 64, value = 3);
  assertEquals(buffer.len, 64);
  assertEquals(array.len(), 64);
  assertEquals(list.len, 64);
  for buffer do {
    assertEquals(buffer.get(itIndex), 3);
    assertEquals(list.get(itIndex), 3);
    assertEquals(array.get(itIndex), 3);
  }
}

fn testArray(): unit {
  let context alloc: mem/AllocMode = mem/AllocMode/TEMP;
  let ls: List[u8] = List/filledIn(size = 10, value = 3);

  let a: Array[10 x u8]* = listToArray(ls, 10);
  let* w = List/empty[char]();
  for core/IntRange/upTo(a.len() as iword) do {
    if it % 2 == 0 { a.getRef(it as uword) <- 1 };
  };
  for core/IntRange/upTo(a.len() as iword) do {
    println("{it}: {a.get(it as uword)}");
  };

}

fn main(): i32 {
  // nocommit(0); commit array test
  assertEquals(types/sizeOf[Thing](), 9216);

  #static testArray();
  testArray();

  testLiterals();
  testFilled();

  assert(testCompile(array.get(11)) is .Some(_));

  let* array: Array[10 x f32]* = mem/zeroed();
  array.set(0, 3.14);
  let buf = Buffer/fromArray(array);
  assert(buf.get(0) == array.get(0));
  assertEquals(buf.get(0), array.get(0));

  println("first elem is: {buf.get(0)}");
  println("first elem is: {array.get(0)}");

  let x = 44: uword;
  array.get(x);

  0
}
