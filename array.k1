fn bufferFromArray[N: static uword, T](array: Array[N x T]*): Buffer[T] {
  let base = array.getBase();
  let l = array.len();
  Buffer/fromBaseAndCount(l, array.getBase()).cloned()
}

fn listToArray[N: static uword, T](list: List[T], count: N): Array[N x T]* {
  let countVal = count.fromStatic();
  assertEquals(list.len, countVal);
  let base: Pointer = list.toBuffer().cloned().dataPointer();
  base as Array[N x T]*
}

deftype Thing = {
  data: Array[1024 x u8],
  data2: Array[1024 x u64],
}

fn testArray(): unit {
  let context alloc: mem/AllocMode = mem/AllocMode/TEMP;
  let ls: List[u8] = [3 x 10];
  let ten = (10: uword).toStatic();

  for ls do { println("{it}") };

  let a: Array[10 x u8]* = listToArray(ls, ten);
  let* w = List/empty[char]();
  for core/IntRange/upTo(a.len() as iword) do {
    if it % 2 == 0 { a.getRef(it as uword) <- 1 };
  };
  for core/IntRange/upTo(a.len() as iword) do {
    println("{it}: {a.get(it as uword)}");
  };
}

fn main(): i32 {
  // nocommit(0); commit array test
  assertEquals(types/sizeOf[Thing](), 9216);

  #static testArray();
  testArray();

  0
}
