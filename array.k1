fn bufferFromArray[N: static uword, T](array: Array[N x T]*): Buffer[T] {
  let base = array.getBase();
  let l = array.len();
  Buffer/fromBaseAndCount(l, array.getBase()).cloned()
}

fn listToArray[N: static uword, T](list: List[T], count: N): Array[N x T]* {
  let countVal = count.fromStatic();
  assertEquals(list.len, countVal);
  let base: Pointer = list.toBuffer().cloned().dataPointer();
  base as Array[N x T]*
}

deftype Thing = {
  data: Array[1024 x u8],
  data2: Array[1024 x u64],
}

fn testLiterals(): unit {
  let* array: Array[3 x bool]* = [false, true, true];
  let buffer: Buffer[bool] = [false, true, true];
  let list: List[bool] = [false, true, true];
  assertEquals(array.toBuffer(), buffer);
  assertEquals(list.toBuffer(), buffer);
}

fn testFilled(): unit {
  let context alloc: mem/AllocMode = mem/AllocMode/TEMP;
  let buffer: Buffer[u8] = Buffer/filledIn(size = 64, value = 3);
  // this doesnt infer because we don't look at the return type first
  // let array: Array[64 x u8] = Array/filledIn(3, (64: uword).toStatic());
  let array: Array[64 x u8] = Array/filledIn(3: u8, (64: uword).toStatic());
  let list: List[u8] = List/filledIn(size = 64, value = 3);
  assertEquals(buffer.len, 64);
  assertEquals(array.len(), 64);
  assertEquals(list.len, 64);
  for buffer do {
    assertEquals(buffer.get(itIndex), 3);
    assertEquals(list.get(itIndex), 3);
    assertEquals(array.get(itIndex), 3);
  }
}

fn testArray(): unit {
  let context alloc: mem/AllocMode = mem/AllocMode/TEMP;
  let ls: List[u8] = List/filledIn(size = 10, value = 3);
  let ten = (10: uword).toStatic();

  for ls do { println("{it}") };

  let a: Array[10 x u8]* = listToArray(ls, ten);
  let* w = List/empty[char]();
  for core/IntRange/upTo(a.len() as iword) do {
    if it % 2 == 0 { a.getRef(it as uword) <- 1 };
  };
  for core/IntRange/upTo(a.len() as iword) do {
    println("{it}: {a.get(it as uword)}");
  };

}

fn main(): i32 {
  // nocommit(0); commit array test
  assertEquals(types/sizeOf[Thing](), 9216);

  #static testArray();
  testArray();

  testLiterals();
  testFilled();

  0
}
