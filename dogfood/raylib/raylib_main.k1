ns raylib {
  deftype Color = {
    r: u8, g: u8, b: u8, a: u8
  }
  ns Color {
    fn rgba(r: u8, g: u8, b: u8, a: u8): u32 {
      let v: u32 = r as u32;
      v := v.bitOr((g as u32).shiftLeft(8));
      v := v.bitOr((b as u32).shiftLeft(16));
      v := v.bitOr((a as u32).shiftLeft(24));
      v
    }
    fn u32(self: Color): u32 {
      rgba(self.r, self.g, self.b, self.a)
    }
  }

  deftype Rectangle = {
    x: f32, y: f32, width: f32, height: f32
  }
  extern("InitWindow") fn init(width: i32, height: i32, name: Pointer): unit
  extern("CloseWindow") fn CloseWindow(): unit
  extern("WindowShouldClose") fn WindowShouldClose(): bool

  extern("BeginDrawing") fn BeginDrawing(): unit
  extern("EndDrawing") fn EndDrawing(): unit
  extern("ClearBackground") fn ClearBackground(color: u32): unit
  extern("DrawText") fn DrawText(text: Pointer, posX: i32, posY: i32, color: u32): unit

  extern("SetTargetFPS") fn SetTargetFPS(fps: i32): unit
  extern("GetFPS") fn GetFPS(): i32

}
// TODO: We need a good 'void' return because if you try to access the unit
//       I think it won't be a unit since there's no return value at all

let RED: raylib/Color = { r: 255, g: 0, b: 0, a: 255 };
let GRAY: raylib/Color = { r: 200, g: 200, b: 200, a: 255 };
let PINK: raylib/Color = { r: 255, g: 109, b: 194, a: 255 };
let PURPLE: raylib/Color = { r: 200, g: 122, b: 255, a: 255 };

fn main(): i32 {
    let context allocMode = core/mem/AllocMode/TEMP;
    raylib/init(800, 450, "raylib [core] example - basic window".toCString().ptr);
    raylib/SetTargetFPS(60);

    use raylib/ClearBackground;
    use raylib/DrawText;

    let i = 0;
    while not raylib/WindowShouldClose() {
      raylib/BeginDrawing();
      let color = if i < 1000 PURPLE.u32() else PINK.u32();
      ClearBackground(color);
      DrawText("Congrats!".toCString().ptr, 200, 200, GRAY.u32());
      raylib/EndDrawing();
      i := i + 1;
      if i == 2000 { i := 0 };
    };

    raylib/CloseWindow();

    0
}
