// The efficient representation, a Bitboard encoding
deftype Color = either White, Black
deftype GameState = {
  wPawns: u64,
  wKnights: u64,
  wBishops: u64,
  wRooks: u64,
  wQueens: u64,
  wKings: u64,

  bPawns: u64,
  bKnights: u64,
  bBishops: u64,
  bRooks: u64,
  bQueens: u64,
  bKings: u64,

  castleRights: u8,
  enPassantFile: u8?,
  turn: Color
}

ns GameState {
  fn startPos(): GameState {
    let wPawns   = 0b0000000000000000000000000000000000000000000000001111111100000000: u64;
    let wKnights = 0b0000000000000000000000000000000000000000000000000000000001000010: u64;
    let wBishops = 0b0000000000000000000000000000000000000000000000000000000000100100: u64;
    let wRooks   = 0b0000000000000000000000000000000000000000000000000000000010000001: u64;
    let wQueens  = 0b0000000000000000000000000000000000000000000000000000000000010000: u64;
    let wKings   = 0b0000000000000000000000000000000000000000000000000000000000001000: u64;
    let bPawns   = 0b0000000011111111000000000000000000000000000000000000000000000000: u64;
    let bKnights = 0b0100001000000000000000000000000000000000000000000000000000000000: u64;
    let bBishops = 0b0010010000000000000000000000000000000000000000000000000000000000: u64;
    let bRooks   = 0b1000000100000000000000000000000000000000000000000000000000000000: u64;
    let bQueens  = 0b0001000000000000000000000000000000000000000000000000000000000000: u64;
    let bKings   = 0b0000100000000000000000000000000000000000000000000000000000000000: u64;
    { wPawns, wKnights, wBishops, wRooks, wQueens, wKings, 
      bPawns, bKnights, bBishops, bRooks, bQueens, bKings, 
      castleRights: 0b00000011, enPassantFile: some(0: u8), turn: .White }
  }

  fn genMoves(self: GameState): List[Move] {
    crash("todo")
  }
}

deftype Move = { from: u8, to: u8 }

fn cmdInfo(): string {
  // Here you would register any options the engine supports
  // println("option name Hash type spin default 16 min 1 max 32768");
  // println("option name Skill Level type spin default 20 min 0 max 20");
  [
    "id name refchess alpha",
    "id author Koleman Nix",
    "uciok"
  ].join("\n")
}

fn cmdGo(go: string): string {
  "bestmove e2e4"
  // Or if pondering:
  // "bestmove e2e4 ponder e7e5";
}

fn cmdIsReady(): string {
  "readyok"
}

fn cmdNewGame(): unit {
  ()
}


fn handleCommand(context eng: Engine)(command: uci/Command): string? {
  switch command {
    .Uci -> some(cmdInfo()),
    .Go(s) -> some(cmdGo(s)),
    .IsReady -> some(cmdIsReady()),
    .NewGame -> { cmdNewGame(); none() },
    .Quit -> {
      eprintln("Quitting");
      sys/exit(0)
    },
    .Position(s) -> {
      debugLog("Setting position: \{s}");
      none()
    }

  }
}

deftype Engine = {}
ns Engine {
  fn inDebugMode(self: Engine): bool { true }
}

fn debugLog(context eng: Engine)(s: string): unit {
  if eng.inDebugMode() {
    println("[debug] \{s}");
  }
}

fn main(): int {
  // Initialize stdin reading
  let context eng: Engine = {};
  loop {
    switch sys/readLine(2048) {
      .Err(msg) -> { crash("Failed to readLine: \{msg}") },
      .Ok(cmd) -> {
        switch uci/parseCommand(cmd) {
          .Err(msg) -> eprintln("[debug] Ignoring unknown command: \{msg}"),
          .Ok(cmd) -> {
            let response = handleCommand(cmd);
            // If a command produces output, it goes to stdout with a newline added
            if response is .Some(r) { println(r) };
          }
        }
      }
    }
  };
  
  0
}
